<script>
// ---------------------- æ¡ä»¶è©•ä¾¡é–¢æ•° ----------------------
function evalCondition(block){
  if(!block) return 0;
  if(block.getValue) {
    const val = block.getValue();
    if(typeof val === "string") return val !== "" ? 1 : 0;
    return Number(val);
  }
  if(block.type === "direct_number") return Number(block.getFieldValue("value"));
  if(block.type === "arithmetic") {
    const A = evalCondition(block.getInputTargetBlock("A")) || 0;
    const B = evalCondition(block.getInputTargetBlock("B")) || 0;
    const op = block.getFieldValue("OP");
    switch(op){
      case "ADD": return A + B;
      case "MINUS": return A - B;
      case "MULTIPLY": return A * B;
      case "DIVIDE": return B !== 0 ? A / B : 0;
    }
  }
  // è¿½åŠ æ¼”ç®—ã®è©•ä¾¡
  if(block.type === 'modulo'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return B !== 0 ? (A % B) : 0;
  }
  if(block.type === 'power'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.pow(A, B);
  }
  if(block.type === 'sqrt'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.sqrt(v);
  }
  if(block.type === 'abs'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.abs(v);
  }
  if(block.type === 'negate'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return -v;
  }
  if(block.type === 'round'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.round(v);
  }
  if(block.type === 'floor'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.floor(v);
  }
  if(block.type === 'ceil'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.ceil(v);
  }
  if(block.type === 'min'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.min(A,B);
  }
  if(block.type === 'max'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.max(A,B);
  }
  if(block.type === 'clamp'){
    const val = Number(evalCondition(block.getInputTargetBlock('VAL')) || 0);
    const mn = Number(evalCondition(block.getInputTargetBlock('MIN')) || 0);
    const mx = Number(evalCondition(block.getInputTargetBlock('MAX')) || 0);
    if(isNaN(mn) || isNaN(mx)) return val;
    const low = Math.min(mn,mx), high = Math.max(mn,mx);
    return Math.min(Math.max(val, low), high);
  }
  if(block.type === 'random_int'){
    let mn = Number(evalCondition(block.getInputTargetBlock('MIN')) || 0);
    let mx = Number(evalCondition(block.getInputTargetBlock('MAX')) || 0);
    mn = Math.ceil(mn); mx = Math.floor(mx);
    if(mx < mn){ const t = mn; mn = mx; mx = t; }
    const range = mx - mn + 1;
    if(range <= 0) return mn;
    return Math.floor(Math.random() * range) + mn;
  }
  if(block.type === 'random_float'){
    return Math.random();
  }
  if(block.type === 'length'){
    try{
      const inBlock = block.getInputTargetBlock('INPUT');
      if(inBlock && inBlock.getValue){
        const v = inBlock.getValue();
        if(Array.isArray(v)) return v.length;
        if(typeof v === 'string') return v.length;
        if(typeof v === 'number') return String(v).length;
      }
      // fallback: evaluate nested block
      const maybe = evalCondition(inBlock);
      if(Array.isArray(maybe)) return maybe.length;
      if(typeof maybe === 'string') return maybe.length;
      if(typeof maybe === 'number') return String(maybe).length;
    }catch(e){/* ignore */}
    return 0;
  }
  if(block.type === 'date_add_days'){
    try{
      const dateBlock = block.getInputTargetBlock('DATE');
      let baseDate = null;
      if(dateBlock){
        // try getValue() from form-like blocks
        if(typeof dateBlock.getValue === 'function'){
          const gv = dateBlock.getValue();
          if(typeof gv === 'string' && gv.trim() !== '') baseDate = new Date(gv);
          else if(typeof gv === 'number') baseDate = new Date(gv);
        }
        if(!baseDate){
          try{
            const txt = dateBlock.getFieldValue && (dateBlock.getFieldValue('value') || dateBlock.getFieldValue('label') || dateBlock.getFieldValue('TEXT') || '');
            if(txt) baseDate = new Date(txt);
          }catch(e){}
        }
        if(!baseDate){
          const num = evalCondition(dateBlock);
          if(typeof num === 'number' && !isNaN(num)){
            if(num > 1e11) baseDate = new Date(num);
            else {
              const s = String(num);
              if(s.length === 8){
                const y = Number(s.slice(0,4)), m = Number(s.slice(4,6))-1, d = Number(s.slice(6,8));
                baseDate = new Date(y,m,d);
              } else {
                baseDate = new Date(num);
              }
            }
          }
        }
      }
      if(!baseDate || isNaN(baseDate.getTime())) baseDate = new Date();
      const days = Number(evalCondition(block.getInputTargetBlock('DAYS')) || 0);
      const result = new Date(baseDate.getTime() + days * 24 * 60 * 60 * 1000);
      const y = result.getFullYear();
      const m = String(result.getMonth()+1).padStart(2,'0');
      const d = String(result.getDate()).padStart(2,'0');
      return `${y}-${m}-${d}`;
    }catch(e){ return ''; }
  }
  // get_position: return current actor position as "x,y"
  if(block.type === 'get_position'){
    try{
      const a = window._actor || {x:0,y:0};
      return `${a.x},${a.y}`;
    }catch(e){ return '0,0'; }
  }
  return 0;
}

function evalIfCondition(block){
  if(!block) return false;
  const left = evalCondition(block.getInputTargetBlock("LEFT"));
  const right = evalCondition(block.getInputTargetBlock("RIGHT"));
  const op = block.getFieldValue("OP");
  switch(op){
    case "EQ": return left == right;
    case "NEQ": return left != right;
    case "GT": return left > right;
    case "LT": return left < right;
    case "GTE": return left >= right;
    case "LTE": return left <= right;
  }
  return false;
}

// Collect answers rendered in #visual-area: label -> value
function collectAnswers(){
  const pairs = {};
  try{
    const rows = Array.from(document.querySelectorAll('#visual-area .form-row'));
    rows.forEach(row => {
      // Determine label robustly: prefer <label for="...">, then leading text node, then any <label>
      let label = '';
      const labelFor = row.querySelector('label[for]');
      if(labelFor) label = labelFor.innerText.trim();
      if(!label){
        // look for leading text node (used by radio_choice and others)
        for(const node of row.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            const t = node.textContent.trim();
            if(t){ label = t; break; }
          }
          // if it's an element and not an input/label, try its text
          if(node.nodeType === Node.ELEMENT_NODE && !['INPUT','LABEL'].includes(node.tagName)){
            const t = node.textContent.trim(); if(t){ label = t; break; }
          }
        }
      }
      if(!label){
        const anyLabel = row.querySelector('label');
        if(anyLabel) label = anyLabel.innerText.trim();
      }
      if(!label) label = (row.dataset.label || '').trim();
      if(!label) return;

      // Collect value by input type
      const inputText = row.querySelector('input[type="text"], textarea');
      if(inputText){ pairs[label] = inputText.value; return; }
      const inputNumber = row.querySelector('input[type="number"]');
      if(inputNumber){ pairs[label] = inputNumber.value; return; }
      const inputFile = row.querySelector('input[type="file"]');
      if(inputFile){
        const files = inputFile.files;
        if(files && files.length){
          pairs[label] = Array.from(files).map(f=>f.name).join(', ');
        } else {
          pairs[label] = '';
        }
        return;
      }
      const radios = row.querySelectorAll('input[type="radio"]');
      if(radios && radios.length){
        const name = radios[0].name;
        const checked = row.querySelector(`input[name="${name}"]:checked`);
        pairs[label] = checked ? checked.value : '';
        return;
      }
      const checkboxes = row.querySelectorAll('input[type="checkbox"]');
      if(checkboxes && checkboxes.length){
        const vals = Array.from(checkboxes).filter(c=>c.checked).map(c=>c.value);
        pairs[label] = vals.join(',');
        return;
      }
      // fallback: take visible text
      pairs[label] = row.innerText.replace(/\n/g,' ').trim();
    });
  }catch(e){ console.error('collectAnswers error', e); }
  return pairs;
}

// ---------------------- å®Ÿè¡Œé–¢æ•° ----------------------
async function runBlocks(){
  visual.innerHTML = "";
  const blocks = workspace.getTopBlocks(true);

  async function processBlock(block){
    if(!block) return;

    if(block.updateVisual) block.updateVisual(visual);
    else{
      switch(block.type){
        case 'controls_repeat_custom':
          const times = evalCondition(block.getInputTargetBlock("TIMES")) || 0;
          const doBlock = block.getInputTargetBlock("DO");
          for(let i = 0; i < times; i++){
            if(doBlock){
              try{ await processBlock(doBlock); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { continue; }
                if(ctrl && ctrl.control === 'break') { break; }
                throw ctrl;
              }
            }
          }
          break;

        case 'controls_if_custom':
          if(evalIfCondition(block)){
            const doBlock = block.getInputTargetBlock("DO");
            if(doBlock) await processBlock(doBlock);
          }
          break;

        case 'controls_while':
          try{
            const condBlock = block.getInputTargetBlock("COND");
            const doBlock = block.getInputTargetBlock("DO");
            // å®‰å…¨ç­–: ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®ãŸã‚æœ€å¤§åå¾©å›æ•°ã‚’è¨­ã‘ã‚‹
            const MAX_ITER = 1000;
            let iter = 0;
            while((evalCondition(condBlock) || 0) !== 0){
              if(!doBlock) break;
              try{ await processBlock(doBlock); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iter++;
              if(iter >= MAX_ITER){
                visual.innerHTML += `<div class="form-row">(ãƒ«ãƒ¼ãƒ—ãŒæœ€å¤§åå¾© ${MAX_ITER} ã«é”ã—ã¾ã—ãŸ â€” ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²æ­¢ã—ã¦åœæ­¢)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_while error', e); }
          break;

        case 'controls_repeat_until':
          try{
            const condBlockRU = block.getInputTargetBlock("COND");
            const doBlockRU = block.getInputTargetBlock("DO");
            const MAX_ITER_RU = 1000;
            let iterRU = 0;
            // æ¡ä»¶ãŒçœŸã«ãªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã™ -> æ¡ä»¶ãŒå½ã®é–“ãƒ«ãƒ¼ãƒ—
            while(((evalCondition(condBlockRU) || 0) === 0)){
              if(!doBlockRU) break;
              try{ await processBlock(doBlockRU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iterRU++;
              if(iterRU >= MAX_ITER_RU){
                visual.innerHTML += `<div class="form-row">(Repeat Until: åå¾©ãŒæœ€å¤§ ${MAX_ITER_RU} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_repeat_until error', e); }
          break;

        case 'controls_do_until':
          try{
            const doBlockDU = block.getInputTargetBlock("DO");
            const condBlockDU = block.getInputTargetBlock("COND");
            const MAX_ITER_DU = 1000;
            let iterDU = 0;
            // æœ€ä½1å›ã¯å®Ÿè¡Œã—ã¦ã‹ã‚‰æ¡ä»¶ã‚’è©•ä¾¡
            if(doBlockDU){
              try{ await processBlock(doBlockDU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* continue to condition check */ }
                else if(ctrl && ctrl.control === 'break') { /* break outer do-until */ return; }
                else throw ctrl;
              }
            }
            while(((evalCondition(condBlockDU) || 0) === 0)){
              if(!doBlockDU) break;
              try{ await processBlock(doBlockDU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iterDU++;
              if(iterDU >= MAX_ITER_DU){
                visual.innerHTML += `<div class="form-row">(Do-Until: åå¾©ãŒæœ€å¤§ ${MAX_ITER_DU} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_do_until error', e); }
          break;

        case 'controls_for':
          try{
            const fromBlock = block.getInputTargetBlock("FROM");
            const toBlock = block.getInputTargetBlock("TO");
            const byBlock = block.getInputTargetBlock("BY");
            const doBlockF = block.getInputTargetBlock("DO");
            let from = Number(evalCondition(fromBlock) || 0);
            let to = Number(evalCondition(toBlock) || 0);
            let by = Number(evalCondition(byBlock) || 1);
            if(by === 0) by = 1; // å¢—åˆ†0ã¯é¿ã‘ã‚‹

            const MAX_ITER_F = 10000;
            let iterF = 0;

            // ãƒ«ãƒ¼ãƒ—æ–¹å‘ã«å¿œã˜ã¦æ¡ä»¶ã‚’åˆ¤å®š
            const forward = by > 0;
            // expose current index to potential custom blocks via global (å°†æ¥çš„ã«å°‚ç”¨ãƒ–ãƒ­ãƒƒã‚¯ã§å–å¾—å¯èƒ½)
            if(typeof window._for_index === 'undefined') window._for_index = null;

            if(forward){
              for(let i = from; i <= to; i += by){
                window._for_index = i;
                if(doBlockF){
                  try{ await processBlock(doBlockF); }
                  catch(ctrl){
                    if(ctrl && ctrl.control === 'continue') { continue; }
                    if(ctrl && ctrl.control === 'break') { break; }
                    throw ctrl;
                  }
                }
                iterF++;
                if(iterF >= MAX_ITER_F){
                  visual.innerHTML += `<div class="form-row">(For: åå¾©ãŒæœ€å¤§ ${MAX_ITER_F} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                  break;
                }
              }
            } else {
              for(let i = from; i >= to; i += by){
                window._for_index = i;
                if(doBlockF){
                  try{ await processBlock(doBlockF); }
                  catch(ctrl){
                    if(ctrl && ctrl.control === 'continue') { continue; }
                    if(ctrl && ctrl.control === 'break') { break; }
                    throw ctrl;
                  }
                }
                iterF++;
                if(iterF >= MAX_ITER_F){
                  visual.innerHTML += `<div class="form-row">(For: åå¾©ãŒæœ€å¤§ ${MAX_ITER_F} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                  break;
                }
              }
            }
            window._for_index = null;
          }catch(e){ console.error('controls_for error', e); }
          break;

        case 'controls_forever':
          try{
            const doBlockForever = block.getInputTargetBlock('DO');
            const MAX_FOREVER = 100000;
            let iterFv = 0;
            while(true){
              if(doBlockForever){
                try{ await processBlock(doBlockForever); }
                catch(ctrl){
                  if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                  else if(ctrl && ctrl.control === 'break') { break; }
                  else throw ctrl;
                }
              }
              iterFv++;
              if(iterFv >= MAX_FOREVER){
                visual.innerHTML += `<div class="form-row">(Forever: åå¾©ãŒæœ€å¤§ ${MAX_FOREVER} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_forever error', e); }
          break;

        case 'controls_for_each':
          try{
            const listBlock = block.getInputTargetBlock("LIST");
            const varName = block.getFieldValue("VAR") || 'item';
            const doBlockFE = block.getInputTargetBlock("DO");

            function resolveList(lb){
              if(!lb) return [];
              // If block provides a getValue() (form blocks), use it
              if(lb.getValue){
                try{
                  const v = lb.getValue();
                  if(Array.isArray(v)) return v;
                  if(typeof v === 'string') return v.split(',').map(s=>s.trim()).filter(s=>s!=='');
                  if(typeof v === 'number') return [v];
                }catch(e){ /* ignore */ }
              }
              // If it's a direct number or arithmetic, evaluate as number
              if(lb.type === 'direct_number' || lb.type === 'arithmetic'){
                const n = evalCondition(lb);
                return [n];
              }
              // Fallback: try evalCondition (may return number)
              const maybe = evalCondition(lb);
              if(typeof maybe === 'number' && !isNaN(maybe)) return [maybe];
              // If lb has a field 'value' (rare), read it
              try{
                const f = lb.getFieldValue && lb.getFieldValue('value');
                if(typeof f === 'string') return f.split(',').map(s=>s.trim()).filter(s=>s!=='');
              }catch(e){}
              return [];
            }

            const items = resolveList(listBlock);
            const MAX_FE = 10000;
            let iterFE = 0;
            if(typeof window._for_each_item === 'undefined') window._for_each_item = null;
            if(typeof window._for_each_index === 'undefined') window._for_each_index = null;
            if(typeof window._vars === 'undefined') window._vars = {};

            for(let idx = 0; idx < items.length; idx++){
              window._for_each_index = idx;
              window._for_each_item = items[idx];
              // expose variable name for potential use blocks
              window._vars[varName] = items[idx];
              if(doBlockFE){
                try{ await processBlock(doBlockFE); }
                catch(ctrl){
                  if(ctrl && ctrl.control === 'continue') { /* next item */ continue; }
                  if(ctrl && ctrl.control === 'break') { break; }
                  throw ctrl;
                }
              }
              iterFE++;
              if(iterFE >= MAX_FE){
                visual.innerHTML += `<div class="form-row">(ForEach: åå¾©ãŒæœ€å¤§ ${MAX_FE} ã«é”ã—ã¾ã—ãŸ â€” åœæ­¢)</div>`;
                break;
              }
            }
            // cleanup
            window._for_each_item = null;
            window._for_each_index = null;
            delete window._vars[varName];
          }catch(e){ console.error('controls_for_each error', e); }
          break;

        case 'controls_switch':
          try{
            const valBlock = block.getInputTargetBlock('VALUE');
            const switchValRaw = (function(){
              // try numeric evaluation first
              const num = evalCondition(valBlock);
              if(typeof num === 'number' && !isNaN(num) && String(num) !== '0') return num;
              // if evalCondition returned 0, it could be falsy for strings; try fieldValue
              try{
                if(valBlock && valBlock.getFieldValue){
                  const f = valBlock.getFieldValue('value') || valBlock.getFieldValue('label') || valBlock.getFieldValue('TEXT') || valBlock.getFieldValue('VALUE');
                  if(typeof f === 'string') return f;
                }
              }catch(e){}
              return num;
            })();

            let matched = false;
            let executed = false;
            let caseBlock = block.getInputTargetBlock('DO');
            // iterate case/default blocks linked under DO
            while(caseBlock){
              if(caseBlock.type === 'controls_case'){
                const caseVal = caseBlock.getFieldValue('VALUE');
                // compare: numeric vs numeric or string vs string
                let isMatch = false;
                // numeric compare when both numeric
                if(!isNaN(Number(switchValRaw)) && !isNaN(Number(caseVal))){
                  isMatch = Number(switchValRaw) === Number(caseVal);
                } else {
                  const a = (switchValRaw===null||switchValRaw===undefined)?'':String(switchValRaw).trim();
                  const b = (caseVal===null||caseVal===undefined)?'':String(caseVal).trim();
                  // remove surrounding quotes if present
                  const strip = s => (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'")) ? s.slice(1,-1) : s;
                  isMatch = strip(a) === strip(b);
                }

                if(isMatch){
                  // execute case body and then stop unless break/continue control is used
                  const body = caseBlock.getInputTargetBlock('DO');
                  if(body){
                    try{ await processBlock(body); }
                    catch(ctrl){
                      if(ctrl && ctrl.control === 'continue') { /* continue to next case */ }
                      else if(ctrl && ctrl.control === 'break') { executed = true; matched = true; break; }
                      else throw ctrl;
                    }
                    executed = true; matched = true; break;
                  } else { matched = true; break; }
                }
              } else if(caseBlock.type === 'controls_default'){
                // default runs if no previous match
                if(!matched){
                  const body = caseBlock.getInputTargetBlock('DO');
                  if(body){
                    try{ await processBlock(body); }
                    catch(ctrl){
                      if(ctrl && ctrl.control === 'continue') { /* no-op */ }
                      else if(ctrl && ctrl.control === 'break') { executed = true; break; }
                      else throw ctrl;
                    }
                    executed = true; break;
                  }
                }
              }
              caseBlock = caseBlock.getNextBlock();
            }
          }catch(e){ console.error('controls_switch error', e); }
          break;

          case 'controls_try':
            try{
              const tryBlock = block.getInputTargetBlock('TRY');
              const catchBlock = block.getInputTargetBlock('CATCH');
              const finallyBlock = block.getInputTargetBlock('FINALLY');
              const errVar = (block.getFieldValue && block.getFieldValue('ERRVAR')) || '';
              try{
                if(tryBlock) await processBlock(tryBlock);
              }catch(err){
                // loop control signals (break/continue) should propagate
                if(err && err.control) throw err;
                // expose caught exception
                try{ window._last_exception = err; }catch(e){}
                if(errVar && typeof window._vars === 'undefined') window._vars = {};
                if(errVar) window._vars[errVar] = err;
                if(catchBlock) {
                  try{ await processBlock(catchBlock); }
                  catch(ctrl){
                    // if catch body raises loop control, propagate
                    if(ctrl && ctrl.control) throw ctrl;
                    else throw ctrl;
                  }
                } else {
                  visual.innerHTML += `<div class="form-row">(ä¾‹å¤–æ•æ‰) ${String(err)}</div>`;
                }
                if(errVar) delete window._vars[errVar];
              } finally {
                // always run finally block
                if(finallyBlock){
                  try{ await processBlock(finallyBlock); }
                  catch(ctrl){
                    if(ctrl && ctrl.control) throw ctrl;
                    else throw ctrl;
                  }
                }
                try{ delete window._last_exception; }catch(e){}
              }
            }catch(e){ console.error('controls_try error', e); }
            break;

        case 'print_text':
          const textVal = block.getFieldValue("TEXT");
          visual.innerHTML += `<p>${textVal}</p>`;
          break;

        case 'load_system':
          const systemId = block.getFieldValue('SYSTEM_ID');
          if (systemId && systemId !== '0') {
            visual.innerHTML += `<div class="form-row">ã‚·ã‚¹ãƒ†ãƒ (ID: ${systemId})ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ</div>`;
            // å®Ÿéš›ã®ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ å¯èƒ½
            // ä¾‹: window.location.href = `/accounts/system/preview/${systemId}/`;
          } else {
            visual.innerHTML += `<div class="form-row">èª­ã¿è¾¼ã‚€ã‚·ã‚¹ãƒ†ãƒ ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</div>`;
          }
          break;

        case 'system_condition':
          const sysId = block.getFieldValue('SYSTEM_ID');
          const elementName = block.getFieldValue('ELEMENT_NAME');
          const op = block.getFieldValue('OP');
          const expectedValue = block.getFieldValue('VALUE');
          
          // APIã‚’ä½¿ã£ã¦ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰è¦ç´ ã®å€¤ã‚’å–å¾—
          try {
            const apiUrl = `/accounts/api/system/${sysId}/element/${encodeURIComponent(elementName)}/`;
            console.log('ğŸ” APIå‘¼ã³å‡ºã—:', apiUrl);
            console.log('ğŸ“ æ¤œç´¢ã™ã‚‹è¦ç´ å:', elementName);
            
            const response = await fetch(apiUrl);
            console.log('ğŸ“¡ ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:', response.status);
            
            const data = await response.json();
            console.log('ğŸ“¦ å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿:', data);
            
            let actualValue = '';
            if (data.success && data.element_value) {
              actualValue = data.element_value;
            } else if (data.element_value === '') {
              actualValue = '';
            }
            
            console.log('âœ… å®Ÿéš›ã®å€¤:', actualValue);
            
            // æ¡ä»¶è©•ä¾¡
            let conditionMet = false;
            switch(op) {
              case 'EQ': 
                conditionMet = (actualValue == expectedValue); 
                break;
              case 'NEQ': 
                conditionMet = (actualValue != expectedValue); 
                break;
              case 'GT': 
                conditionMet = (Number(actualValue) > Number(expectedValue)); 
                break;
              case 'LT': 
                conditionMet = (Number(actualValue) < Number(expectedValue)); 
                break;
              case 'GTE': 
                conditionMet = (Number(actualValue) >= Number(expectedValue)); 
                break;
              case 'LTE': 
                conditionMet = (Number(actualValue) <= Number(expectedValue)); 
                break;
              case 'CONTAINS': 
                conditionMet = actualValue.includes(expectedValue); 
                break;
              case 'SELECTED':
                // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®åˆ¤å®š: å€¤ãŒæœŸå¾…å€¤ã¨ä¸€è‡´ã™ã‚‹ã‹ï¼ˆè¤‡æ•°å€¤ã®ORæ¡ä»¶ã‚‚ã‚µãƒãƒ¼ãƒˆï¼‰
                console.log('ğŸ” ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³åˆ¤å®š:', {
                  actualValue: actualValue,
                  expectedValue: expectedValue
                });
                
                // æœŸå¾…å€¤ãŒ/åŒºåˆ‡ã‚Šã®å ´åˆã¯è¤‡æ•°æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã„ãšã‚Œã‹ã«ä¸€è‡´ã™ã‚Œã°OKï¼‰
                if (expectedValue.includes('/')) {
                  const expectedValues = expectedValue.split('/').map(v => v.trim());
                  conditionMet = expectedValues.some(ev => {
                    const matched = (actualValue === ev);
                    console.log(`  - "${ev}" ã¨ã®æ¯”è¼ƒ: ${matched ? 'âœ“' : 'âœ—'}`);
                    return matched;
                  });
                  console.log('  â†’ æœ€çµ‚åˆ¤å®š:', conditionMet ? 'æ¡ä»¶æº€ãŸã™' : 'æ¡ä»¶æº€ãŸã•ãªã„');
                } else {
                  // å˜ä¸€å€¤ã®å ´åˆ
                  conditionMet = (actualValue === expectedValue);
                  console.log('  â†’ å˜ä¸€å€¤åˆ¤å®š:', conditionMet ? 'æ¡ä»¶æº€ãŸã™' : 'æ¡ä»¶æº€ãŸã•ãªã„');
                }
                break;
              case 'CHECKED':
                // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®åˆ¤å®š: ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®å€¤ã«æœŸå¾…å€¤ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹
                // è¤‡æ•°ã®å€¤ã‚’/åŒºåˆ‡ã‚Šã§æŒ‡å®šã§ãã‚‹ (ä¾‹: "èª­æ›¸/éŸ³æ¥½/ã‚¹ãƒãƒ¼ãƒ„")
                if (actualValue && typeof actualValue === 'string') {
                  const checkedValues = actualValue.split(',').map(v => v.trim());
                  console.log('ğŸ” ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹åˆ¤å®š:', {
                    actualValue: actualValue,
                    checkedValues: checkedValues,
                    expectedValue: expectedValue
                  });
                  
                  // æœŸå¾…å€¤ãŒ/åŒºåˆ‡ã‚Šã®å ´åˆã¯è¤‡æ•°æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                  if (expectedValue.includes('/')) {
                    const expectedValues = expectedValue.split('/').map(v => v.trim());
                    // ã„ãšã‚Œã‹ä¸€ã¤ã§ã‚‚ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚Œã°true
                    conditionMet = expectedValues.some(ev => {
                      const matched = checkedValues.includes(ev);
                      console.log(`  - "${ev}" ã®ãƒã‚§ãƒƒã‚¯: ${matched ? 'âœ“' : 'âœ—'}`);
                      return matched;
                    });
                    console.log('  â†’ æœ€çµ‚åˆ¤å®š:', conditionMet ? 'æ¡ä»¶æº€ãŸã™' : 'æ¡ä»¶æº€ãŸã•ãªã„');
                  } else {
                    // å˜ä¸€å€¤ã®å ´åˆ
                    conditionMet = checkedValues.includes(expectedValue);
                    console.log('  â†’ å˜ä¸€å€¤åˆ¤å®š:', conditionMet ? 'æ¡ä»¶æº€ãŸã™' : 'æ¡ä»¶æº€ãŸã•ãªã„');
                  }
                } else {
                  conditionMet = (actualValue === expectedValue);
                  console.log('âš ï¸ actualValueãŒæ–‡å­—åˆ—ã§ã¯ãªã„:', actualValue);
                }
                break;
            }
            
            visual.innerHTML += `<div class="form-row">ã‚·ã‚¹ãƒ†ãƒ ${sysId}ã®ã€Œ${elementName}ã€ã®å€¤: "${actualValue}" ${conditionMet ? 'âœ“æ¡ä»¶æº€ãŸã™' : 'âœ—æ¡ä»¶æº€ãŸã•ãªã„'}</div>`;
            
            if (conditionMet) {
              const doBlock = block.getInputTargetBlock('DO');
              if (doBlock) await processBlock(doBlock);
            } else {
              const elseBlock = block.getInputTargetBlock('ELSE');
              if (elseBlock) await processBlock(elseBlock);
            }
          } catch (error) {
            console.error('ã‚·ã‚¹ãƒ†ãƒ è¦ç´ ã®å€¤å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            visual.innerHTML += `<div class="form-row">âš ï¸ ã‚·ã‚¹ãƒ†ãƒ è¦ç´ ã®å€¤ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${error.message}</div>`;
          }
          break;

        case 'display_system':
          const displaySysId = block.getFieldValue('SYSTEM_ID');
          if (displaySysId && displaySysId !== '0') {
            visual.innerHTML += `<div class="form-row">ğŸ“º ã‚·ã‚¹ãƒ†ãƒ (ID: ${displaySysId})ã‚’è¡¨ç¤º</div>`;
          } else {
            visual.innerHTML += `<div class="form-row">âš ï¸ è¡¨ç¤ºã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</div>`;
          }
          break;

        case 'controls_break':
          throw { control: 'break' };

        case 'controls_continue':
          throw { control: 'continue' };

        case 'compare_values':
          try{
            const label = block.getFieldValue('label') || '';
            const expect = String(block.getFieldValue('expect') || '');
            const answers = collectAnswers();
            // If there's a rendered answer for this label, use it. Otherwise treat the label itself as a literal value (allow comparing two literals).
            let actual = '';
            if(Object.prototype.hasOwnProperty.call(answers, label)){
              actual = String(answers[label]);
            } else {
              // fallback: if label looks like a number, use it; if quoted string, unquote; otherwise use label as-is
              const trimmed = label.trim();
              if(/^[-+]?\d+(?:\.\d+)?$/.test(trimmed)){
                actual = trimmed;
              } else if((trimmed.startsWith('"') && trimmed.endsWith('"')) || (trimmed.startsWith("'") && trimmed.endsWith("'"))){
                actual = trimmed.slice(1,-1);
              } else {
                actual = trimmed;
              }
            }

            const eqNumeric = !isNaN(Number(actual)) && !isNaN(Number(expect)) && Number(actual) === Number(expect);
            const eqString = typeof actual === 'string' && typeof expect === 'string' && actual.trim().toLowerCase() === expect.trim().toLowerCase();
            const ok = (actual === expect) || eqNumeric || eqString;

            visual.innerHTML += `<div class="form-row">${label}: ${actual} â†’ <strong>${ok? 'æ­£è§£':'ä¸æ­£è§£'}</strong></div>`;
            const row = Array.from(document.querySelectorAll('#visual-area .form-row')).find(r=>{
              const l = r.querySelector('label'); return l && l.innerText.trim() === label;
            });
            if(row) row.style.outline = ok ? '2px solid #4caf50' : '2px solid #e53935';
          }catch(e){ console.error('compare_values error', e); }
          break;

        case 'radio_choice':
        case 'radio_free':
        case 'checkbox_free':
        case 'number_input':
        case 'show_text':
          const val = block.getValue?.();
          if(val !== undefined && val !== null && val !== "") {
            visual.innerHTML += `<p>${val}</p>`;
          }
          break;

        case 'move_steps':
          visual.innerHTML += `<p>${block.getFieldValue('steps')}æ­©å‹•ã‹ã™</p>`; break;
        case 'turn_right':
          visual.innerHTML += `<p>${block.getFieldValue('degrees')}åº¦å³ã«å›ã™</p>`; break;
        case 'turn_left':
          visual.innerHTML += `<p>${block.getFieldValue('degrees')}åº¦å·¦ã«å›ã™</p>`; break;
        case 'goto_xy':
          // å³æ™‚ãƒ†ãƒ¬ãƒãƒ¼ãƒˆçš„ã«ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
          try{
            const tx = Number(block.getFieldValue('x') || 0);
            const ty = Number(block.getFieldValue('y') || 0);
            if(window._actor.stopped){ visual.innerHTML += `<p>(åœæ­¢ä¸­) ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(ä¸€æ™‚åœæ­¢ä¸­) ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã¯ä¿ç•™ã•ã‚Œã¾ã™</p>`; break; }
            const prevX = window._actor.x, prevY = window._actor.y;
            const dx = tx - prevX, dy = ty - prevY;
            const dist = Math.hypot(dx,dy);
            // update position immediately; simulate elapsed time based on speed if speed>0
            const duration = window._actor.speed > 0 ? (dist / window._actor.speed) : 0;
            window._actor.x = tx; window._actor.y = ty; window._actor.simTime += duration;
            visual.innerHTML += `<p>åº§æ¨™ã‚’ (${tx}, ${ty}) ã«ã™ã‚‹ â€” è·é›¢ ${dist.toFixed(2)}ã€çµŒé ${duration.toFixed(2)}s</p>`;
          }catch(e){ visual.innerHTML += `<p>åº§æ¨™è¨­å®šã‚¨ãƒ©ãƒ¼</p>`; }
          break;

        case 'move_relative':
          try{
            if(window._actor.stopped){ visual.innerHTML += `<p>(åœæ­¢ä¸­) ç§»å‹•ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(ä¸€æ™‚åœæ­¢ä¸­) ç§»å‹•ã¯ä¿ç•™ã•ã‚Œã¾ã™</p>`; break; }
            const dx = Number(block.getFieldValue('dx') || 0);
            const dy = Number(block.getFieldValue('dy') || 0);
            const prevX = window._actor.x, prevY = window._actor.y;
            window._actor.x = prevX + dx; window._actor.y = prevY + dy;
            const dist = Math.hypot(dx,dy);
            const duration = window._actor.speed > 0 ? (dist / window._actor.speed) : 0;
            window._actor.simTime += duration;
            visual.innerHTML += `<p>ç›¸å¯¾ç§»å‹• dx:${dx} dy:${dy} â†’ æ–°åº§æ¨™ (${window._actor.x}, ${window._actor.y}) çµŒé ${duration.toFixed(2)}s</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'move_to_duration':
          try{
            if(window._actor.stopped){ visual.innerHTML += `<p>(åœæ­¢ä¸­) ç§»å‹•ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(ä¸€æ™‚åœæ­¢ä¸­) ç§»å‹•ã¯ä¿ç•™ã•ã‚Œã¾ã™</p>`; break; }
            const tx = Number(block.getFieldValue('x') || 0);
            const ty = Number(block.getFieldValue('y') || 0);
            const dur = Number(block.getFieldValue('duration') || 0) || 0;
            const prevX = window._actor.x, prevY = window._actor.y;
            const dist = Math.hypot(tx - prevX, ty - prevY);
            // simulate: set position immediately but account for duration in simTime
            window._actor.x = tx; window._actor.y = ty; window._actor.simTime += dur;
            const impliedSpeed = dur > 0 ? (dist / dur) : 0;
            visual.innerHTML += `<p>æ»‘ã‚‰ã‹ã«ç§»å‹• to (${tx},${ty}) æ‰€è¦ ${dur}s (è·é›¢ ${dist.toFixed(2)}ã€é€Ÿã• ${impliedSpeed.toFixed(2)})</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'set_speed':
          try{
            const sp = Number(block.getFieldValue('speed') || 1);
            window._actor.speed = sp;
            visual.innerHTML += `<p>é€Ÿåº¦ã‚’ ${sp} ã«è¨­å®šã—ã¾ã—ãŸ</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'wait_seconds':
          try{
            const s = Number(block.getFieldValue('secs') || 0);
            window._actor.simTime += s;
            visual.innerHTML += `<p>å¾…æ©Ÿ: ${s} ç§’ï¼ˆæ“¬ä¼¼ï¼‰</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'stop':
          window._actor.stopped = true; window._actor.paused = false;
          visual.innerHTML += `<p>åœæ­¢: ã™ã¹ã¦ã®ç§»å‹•ãŒç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™</p>`;
          break;

        case 'pause':
          window._actor.paused = true;
          visual.innerHTML += `<p>ä¸€æ™‚åœæ­¢: å‹•ä½œã¯ä¿ç•™ã•ã‚Œã¾ã™</p>`;
          break;

        case 'resume':
          window._actor.paused = false;
          visual.innerHTML += `<p>å†é–‹: ä¿ç•™ä¸­ã®å‹•ä½œã¯å†é–‹ã•ã‚Œã¾ã™ï¼ˆåœæ­¢ã¯è§£é™¤ã•ã‚Œã¾ã›ã‚“ï¼‰</p>`;
          break;

        case 'get_position':
          try{
            const a = window._actor || {x:0,y:0};
            visual.innerHTML += `<p>ç¾åœ¨ä½ç½®: (${a.x}, ${a.y})</p>`;
          }catch(e){ }
          break;
        case 'direct_number':
        case 'arithmetic':
        case 'modulo':
        case 'power':
        case 'sqrt':
        case 'abs':
        case 'negate':
        case 'round':
        case 'floor':
        case 'ceil':
        case 'min':
        case 'max':
        case 'clamp':
        case 'random_int':
        case 'random_float':
        case 'length':
        case 'date_add_days':
          visual.innerHTML += `<p>æ¼”ç®—çµæœ: ${evalCondition(block)}</p>`; break;
      }
    }

    const next = block.getNextBlock();
    if(next) await processBlock(next);
  }

  for(const b of blocks) {
    await processBlock(b);
  }
}

visual.innerHTML = "ã“ã“ã«å®Ÿè¡ŒçµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™";
</script>
