{% extends 'base.html' %}
{% load static %}

{% block background_frame %}
<img src="{% static 'codemon/images/frames/bg_frame_purple.png' %}" 
     alt="" 
     class="bg-frame"
     onerror="this.style.display='none';">
{% endblock %}

{% block title %}アルゴリズム作成 - Codemon{% endblock %}

{% block extra_css %}
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<style>
  /* スクロールを有効化 */
  body {
    overflow-y: auto !important;
    height: auto !important;
  }

  /* ナビゲーション表示状態の制御 */
  .top-tabs {
    display: block;
    transition: opacity 0.3s ease;
  }

  /* フィールドと重なった時にナビゲーションバーを非表示 */
  .top-tabs.hidden {
    opacity: 0;
    pointer-events: none;
  }

  /* ----- ページレイアウト ----- */
  .page-wrap{
    max-width:1180px;
    margin:100px auto 40px;
    padding:12px;
    box-sizing:border-box;
  }

  /* ----- 既存スタイル（元ファイルを保持） ----- */
  #container { display: flex; }
  #blocklyDiv { height: 480px; width: 700px; border: 1px solid #ccc; }
  #visual-area {
    width: 500px;
    height: 470px;
    border: 1px solid #000;
    background: #f9f9f9;
    margin-left: 10px;
    overflow-y: auto;
    padding: 5px;
  }
  label { margin-right: 5px; }
  .form-row { margin-bottom: 10px; }
  .shortcut-btns {
    margin-bottom: 10px;
    display: flex;
    align-items: center;
  }
  .shortcut-btns button {
    font-size: 18px;
    margin-right: 5px;
    padding: 4px 12px;
    cursor: pointer;
  }
  .shortcut-btns #runBtn {
    font-size: 18px;
    margin-left: 10px;
    background: #007bff;
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 4px 16px;
  }
  .shortcut-btns #runBtn:hover {
    background: #0056b3;
  }

  /* 保存ボタンスタイル追加 */
  .shortcut-btns #saveBtn {
    font-size: 18px;
    margin-left: 8px;
    background: #28a745;
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 4px 14px;
    cursor: pointer;
  }
  .shortcut-btns #saveBtn:hover {
    background: #1e7e34;
  }

  /* レスポンシブ調整 */
  @media (max-width:1100px){
    #blocklyDiv { width: 60%; }
    #visual-area { width: 36%; margin-left: 8px; }
    .top-nav, .page-wrap { padding-left:10px; padding-right:10px; }
  }
  @media (max-width:760px){
    .top-nav .title { display:none; }
    #container { flex-direction: column; }
    #blocklyDiv, #visual-area { width:100%; margin:6px 0; height:420px; }
  }
</style>
{% endblock %}

{% block content %}
  <main class="page-wrap" role="main">

    <div class="shortcut-btns">
      <button id="undoBtn" title="もどす (Ctrl+Z)">←</button>
      <button id="redoBtn" title="やり直す (Ctrl+Y)">→</button>
      <button id="runBtn" onclick="runBlocks()">うごかす</button>
      <button id="saveBtn">ほぞん</button>
    </div>

    <div id="container">
      <div id="blocklyDiv"></div>
      <div id="visual-area">ここに結果がでるよ</div>
    </div>
  </main>

<!-- ツールボックス -->
<xml id="toolbox" style="display:none">
  <category name="うごき" colour="230">
    <block type="move_steps"></block>
    <block type="turn_right"></block>
    <block type="turn_left"></block>
    <block type="goto_xy"></block>
    <block type="move_relative"></block>
    <block type="move_to_duration"></block>
    <block type="set_speed"></block>
    <block type="wait_seconds"></block>
    <block type="stop"></block>
    <block type="pause"></block>
    <block type="resume"></block>
    <block type="get_position"></block>
  </category>
  <category name="入力" colour="160">
    <block type="show_text"></block>
    <block type="radio_choice"></block>
    <block type="radio_free"></block>
    <block type="checkbox_free"></block> 
    <block type="number_input"></block>
    <block type="print_text"></block>
    <block type="textarea"></block>
    <block type="select_dropdown"></block>
    <block type="date_input"></block>
    <block type="datetime_input"></block>
    <block type="slider"></block>
    <block type="toggle_switch"></block>
    <block type="file_upload"></block>
  </category>
  <category name="計算" colour="200">
    <block type="direct_number"></block>
    <block type="arithmetic"></block>
    <block type="modulo"></block>
    <block type="power"></block>
    <block type="sqrt"></block>
    <block type="abs"></block>
    <block type="negate"></block>
    <block type="round"></block>
    <block type="floor"></block>
    <block type="ceil"></block>
    <block type="min"></block>
    <block type="max"></block>
    <block type="clamp"></block>
    <block type="random_int"></block>
    <block type="random_float"></block>
    <block type="length"></block>
    <block type="date_add_days"></block>
    <block type="compare_values"></block>
  </category>
  <category name="くり返し・条件" colour="120">
    <block type="controls_repeat_custom"></block>
    <block type="controls_if_custom"></block>
    <block type="controls_while"></block>
    <block type="controls_repeat_until"></block>
    <block type="controls_do_until"></block>
    <block type="controls_forever"></block>
    <block type="controls_try"></block>
    <block type="controls_for"></block>
    <block type="controls_for_each"></block>
    <block type="controls_break"></block>
    <block type="controls_continue"></block>
    <block type="controls_switch"></block>
    <block type="controls_case"></block>
    <block type="controls_default"></block>
  </category>
</xml>

<script>
const visual = document.getElementById("visual-area");

// グローバルなエンティティ状態（位置・角度・速度・フラグ）
if(typeof window._actor === 'undefined'){
  window._actor = { x:0, y:0, orientation:0, speed:1, paused:false, stopped:false, simTime:0 };
}

/* ---------------------- ナビタブ（見た目切替 / 遷移） ---------------------- */
(function(){
  try{
    const tabs = document.querySelectorAll('.nav-tab');
    tabs.forEach(tab=>{
      tab.addEventListener('click', (e)=>{
        try{
          // クリックで見た目を切替（押せるようにする）
          tabs.forEach(t=>{
            t.classList.remove('active');
            t.setAttribute('aria-pressed','false');
          });
          tab.classList.add('active');
          tab.setAttribute('aria-pressed','true');
          if(typeof tab.blur === 'function') tab.blur();

          // システムタブ
          if(tab.id === 'tab-system'){
            // system_choice.html へ遷移
            window.location.href = '/accounts/system/choice/';
            return;
          }
          // 変更: アルゴリズムタブ押下で block/choiceへ遷移
          if(tab.id === 'tab-algorithm'){
            window.location.href = '/accounts/block/choice';
            return;
          }
          // 他タブは現状見た目のみ（遷移未実装）
        }catch(err){
          console.error('tab click handler error', err);
        }
      });
    });
  }catch(err){
    console.error('tabs init error', err);
  }
})();

// ---------------------- フォームブロック ----------------------

// テキスト入力フォーム
Blockly.Blocks['show_text'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("テキスト入力（ラベル: ")
      .appendField(new Blockly.FieldTextInput("もじ"), "label")
      .appendField(")");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container) {
      const inputId = "block_" + this.id;
      const labelText = this.getFieldValue("label");
      container.innerHTML += `<div class="form-row">
          <label for="${inputId}">${labelText}</label>
          <input type="text" id="${inputId}"></div>`;
    };
    this.getValue = function() {
      const inputId = "block_" + this.id;
      return document.getElementById(inputId)?.value || "";
    };
  }
};

// 数値入力フォーム
Blockly.Blocks['number_input'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("すうち入力（ラベル: ")
      .appendField(new Blockly.FieldTextInput("かず"), "label")
      .appendField(")");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container) {
      const inputId = "block_" + this.id;
      const labelText = this.getFieldValue("label");
      container.innerHTML += `<div class="form-row">
          <label for="${inputId}">${labelText}</label>
          <input type="number" id="${inputId}"></div>`;
    };
    this.getValue = function() {
      const inputId = "block_" + this.id;
      return Number(document.getElementById(inputId)?.value || 0);
    };
  }
};

// ラジオボタン (固定選択肢)
Blockly.Blocks['radio_choice'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("ラジオ（ラベル: ")
      .appendField(new Blockly.FieldTextInput("しつもん:"), "label")
      .appendField(")");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container) {
      const name = "radio_" + this.id;
      const labelText = this.getFieldValue("label");
      container.innerHTML += `
        <div class="form-row">${labelText}
          <label><input type="radio" name="${name}" value="はい">はい</label>
          <label><input type="radio" name="${name}" value="いいえ">いいえ</label>
        </div>`;
    };
    this.getValue = function() {
      const name = "radio_" + this.id;
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      return checked ? checked.value : "";
    };
  }
};

// ラジオボタン (自由選択肢)
Blockly.Blocks['radio_free'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("ラジオ（ラベル: ")
      .appendField(new Blockly.FieldTextInput("しつもん:"), "label")
      .appendField(" 選ぶもの: ")
      .appendField(new Blockly.FieldTextInput("はい/いいえ/わからない"), "options")
      .appendField(")");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container) {
      const name = "radio_" + this.id;
      const labelText = this.getFieldValue("label");
      const opts = this.getFieldValue("options").split("/");
      container.innerHTML += `<div class="form-row">${labelText}`;
      opts.forEach(o => {
        container.innerHTML += `<label><input type="radio" name="${name}" value="${o}">${o}</label>`;
      });
      container.innerHTML += `</div>`;
    };
    this.getValue = function() {
      const name = "radio_" + this.id;
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      return checked ? checked.value : "";
    };
  }
};

// チェックボックス (自由選択肢)
Blockly.Blocks['checkbox_free'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("チェック（ラベル: ")
      .appendField(new Blockly.FieldTextInput("しつもん:"), "label")
      .appendField(" えらぶもの: ")
      .appendField(new Blockly.FieldTextInput("あ/い/う/え"), "options")
      .appendField(")");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container) {
      const labelText = this.getFieldValue("label");
      const opts = this.getFieldValue("options").split("/");
      container.innerHTML += `<div class="form-row">${labelText}</div>`;
      opts.forEach((o,i)=>{
        container.innerHTML += `<label><input type="checkbox" id="checkbox_${this.id}_${i}" value="${o}">${o}</label>`;
      });
      container.innerHTML += `</div>`;
    };
    this.getValue = function() {
      const inputs = Array.from(document.querySelectorAll(`#visual-area input[type="checkbox"]`))
                          .filter(input => input.parentElement && input.parentElement.innerText.includes(this.getFieldValue("label")));
      return inputs.filter(input => input.checked).map(i=>i.value).join(", ");
    };
  }
};

// ---------------------- 追加フォームブロック ----------------------
// 複数行テキスト入力（textarea）
Blockly.Blocks['textarea'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("ながいもじ（ラベル: ")
      .appendField(new Blockly.FieldTextInput("コメント"), "label")
      .appendField(") ぎょう:")
      .appendField(new Blockly.FieldNumber(4,1,50,1), "rows");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = "block_" + this.id;
      const labelText = this.getFieldValue('label');
      const rows = this.getFieldValue('rows') || 4;
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><br><textarea id="${inputId}" rows="${rows}" style="width:98%"></textarea></div>`;
    };
    this.getValue = function(){
      const inputId = "block_" + this.id;
      return document.getElementById(inputId)?.value || "";
    };
  }
};

// ドロップダウン（select）
Blockly.Blocks['select_dropdown'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('プルダウン（ラベル:')
      .appendField(new Blockly.FieldTextInput('えらぶ'), 'label')
      .appendField(' えらぶもの:')
      .appendField(new Blockly.FieldTextInput('A/B/C'), 'options')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const labelText = this.getFieldValue('label');
      const opts = this.getFieldValue('options').split('/');
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><select id="${inputId}">${opts.map(o=>`<option value="${o}">${o}</option>`).join('')}</select></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      const el = document.getElementById(inputId);
      return el ? el.value : '';
    };
  }
};

// 日付入力
Blockly.Blocks['date_input'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('ひづけ（ラベル:')
      .appendField(new Blockly.FieldTextInput('ひづけ'), 'label')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const labelText = this.getFieldValue('label');
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><input type="date" id="${inputId}"></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      return document.getElementById(inputId)?.value || '';
    };
  }
};

// 日時入力
Blockly.Blocks['datetime_input'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('にちじ（ラベル:')
      .appendField(new Blockly.FieldTextInput('にちじ'), 'label')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const labelText = this.getFieldValue('label');
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><input type="datetime-local" id="${inputId}"></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      return document.getElementById(inputId)?.value || '';
    };
  }
};

// スライダー（range）
Blockly.Blocks['slider'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('スライダー（ラベル:')
      .appendField(new Blockly.FieldTextInput('値'), 'label')
      .appendField(' さいしょう:')
      .appendField(new Blockly.FieldNumber(0), 'min')
      .appendField(' さいだい:')
      .appendField(new Blockly.FieldNumber(100), 'max')
      .appendField(' きざみ:')
      .appendField(new Blockly.FieldNumber(1), 'step')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const spanId = inputId + '_val';
      const labelText = this.getFieldValue('label');
      const min = this.getFieldValue('min') || 0;
      const max = this.getFieldValue('max') || 100;
      const step = this.getFieldValue('step') || 1;
      const initial = Math.min(Math.max((min+max)/2, min), max);
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><input type="range" id="${inputId}" min="${min}" max="${max}" step="${step}" value="${initial}" oninput="document.getElementById('${spanId}').innerText=this.value"><span id="${spanId}" style="margin-left:8px">${initial}</span></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      const v = document.getElementById(inputId)?.value;
      return v !== undefined ? Number(v) : 0;
    };
  }
};

// トグル（ON/OFF）
Blockly.Blocks['toggle_switch'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('スイッチ（ラベル:')
      .appendField(new Blockly.FieldTextInput('ON/OFF'), 'label')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const labelText = this.getFieldValue('label');
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><input type="checkbox" id="${inputId}" style="margin-left:8px"></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      return !!document.getElementById(inputId)?.checked;
    };
  }
};

// ファイルアップロード（簡易）
Blockly.Blocks['file_upload'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('ファイル（ラベル:')
      .appendField(new Blockly.FieldTextInput('ファイル'), 'label')
      .appendField(')');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
    this.updateVisual = function(container){
      const inputId = 'block_' + this.id;
      const labelText = this.getFieldValue('label');
      container.innerHTML += `<div class="form-row"><label for="${inputId}">${labelText}</label><input type="file" id="${inputId}" style="display:block;margin-top:4px"></div>`;
    };
    this.getValue = function(){
      const inputId = 'block_' + this.id;
      const el = document.getElementById(inputId);
      if(!el) return '';
      const files = el.files;
      if(!files || files.length === 0) return '';
      return Array.from(files).map(f=>f.name).join(', ');
    };
  }
};

// ---------------------- 演算ブロック ----------------------

// 直接数値入力
Blockly.Blocks['direct_number'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('すうち:')
      .appendField(new Blockly.FieldNumber(0, -1000, 1000, 1), "value");
    this.setOutput(true, "Number");
    this.setColour(200);
  }
};

// 四則演算
Blockly.Blocks['arithmetic'] = {
  init: function() {
    this.appendValueInput("A").setCheck("Number");
    this.appendDummyInput()
      .appendField(new Blockly.FieldDropdown([["+","ADD"],["-","MINUS"],["×","MULTIPLY"],["÷","DIVIDE"]]), "OP");
    this.appendValueInput("B").setCheck("Number");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(200);
  }
};

// 追加: よく使う演算ブロック群
Blockly.Blocks['modulo'] = {
  init: function(){
    this.appendValueInput('A').setCheck('Number');
    this.appendDummyInput().appendField('あまり (%)');
    this.appendValueInput('B').setCheck('Number');
    this.setInputsInline(true);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['power'] = {
  init: function(){
    this.appendValueInput('A').setCheck('Number');
    this.appendDummyInput().appendField('べき');
    this.appendValueInput('B').setCheck('Number');
    this.setInputsInline(true);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['sqrt'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('ルート');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['abs'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('ぜったいち');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['negate'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('マイナスにする');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['round'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('まるめる');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['floor'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('きりおとす');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['ceil'] = {
  init: function(){
    this.appendValueInput('NUM').setCheck('Number').appendField('きりあげる');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['min'] = {
  init: function(){
    this.appendValueInput('A').setCheck('Number').appendField('さいしょう');
    this.appendValueInput('B').setCheck('Number');
    this.setInputsInline(true);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['max'] = {
  init: function(){
    this.appendValueInput('A').setCheck('Number').appendField('さいだい');
    this.appendValueInput('B').setCheck('Number');
    this.setInputsInline(true);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['clamp'] = {
  init: function(){
    this.appendValueInput('VAL').setCheck('Number').appendField('はさむ');
    this.appendValueInput('MIN').setCheck('Number').appendField('さいしょう');
    this.appendValueInput('MAX').setCheck('Number').appendField('さいだい');
    this.setInputsInline(false);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['random_int'] = {
  init: function(){
    this.appendValueInput('MIN').setCheck('Number').appendField('ランダム(整数) さいしょう');
    this.appendValueInput('MAX').setCheck('Number').appendField('さいだい');
    this.setInputsInline(true);
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

Blockly.Blocks['random_float'] = {
  init: function(){
    this.appendDummyInput().appendField('ランダム (0〜1)');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

// length: 文字列や配列の長さを返す
Blockly.Blocks['length'] = {
  init: function(){
    this.appendValueInput('INPUT').setCheck(null).appendField('ながさ');
    this.setOutput(true,'Number');
    this.setColour(200);
  }
};

// date_add_days: 日付に日数を加算して YYYY-MM-DD を返す
Blockly.Blocks['date_add_days'] = {
  init: function(){
    this.appendValueInput('DATE').setCheck(null).appendField('ひづけ');
    this.appendValueInput('DAYS').setCheck('Number').appendField('にちをたす');
    this.setInputsInline(true);
    this.setOutput(true,null);
    this.setColour(200);
  }
};

// ---------------------- 動き系ブロック ----------------------
Blockly.Blocks['move_steps'] = {
  init: function() {
    this.appendDummyInput()
      .appendField(new Blockly.FieldNumber(10), "steps")
      .appendField("歩く");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

Blockly.Blocks['turn_right'] = {
  init: function() {
    this.appendDummyInput()
      .appendField(new Blockly.FieldNumber(15), "degrees")
      .appendField("右にまわす");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

Blockly.Blocks['turn_left'] = {
  init: function() {
    this.appendDummyInput()
      .appendField(new Blockly.FieldNumber(15), "degrees")
      .appendField("左にまわす");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

Blockly.Blocks['goto_xy'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("xを")
      .appendField(new Blockly.FieldNumber(0), "x")
      .appendField(" yを")
      .appendField(new Blockly.FieldNumber(0), "y")
      .appendField("にする");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

// 追加: 相対移動 (dx, dy)
Blockly.Blocks['move_relative'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('ずらす dx:')
      .appendField(new Blockly.FieldNumber(0), 'dx')
      .appendField(' dy:')
      .appendField(new Blockly.FieldNumber(0), 'dy');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

// 時間付き移動（擬似）: 指定時間で座標へ移動したと見なす
Blockly.Blocks['move_to_duration'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('なめらかにうごく x:')
      .appendField(new Blockly.FieldNumber(0), 'x')
      .appendField(' y:')
      .appendField(new Blockly.FieldNumber(0), 'y')
      .appendField(' じかん(s):')
      .appendField(new Blockly.FieldNumber(1,0,9999,0.1), 'duration');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

// 速度設定
Blockly.Blocks['set_speed'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('はやさを')
      .appendField(new Blockly.FieldNumber(1,0,9999,0.1), 'speed')
      .appendField('にする');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

// 待機（擬似時間を進める）
Blockly.Blocks['wait_seconds'] = {
  init: function(){
    this.appendDummyInput()
      .appendField('まつ 秒:')
      .appendField(new Blockly.FieldNumber(1,0,9999,0.1), 'secs');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(230);
  }
};

// 停止 / 一時停止 / 再開
Blockly.Blocks['stop'] = { init: function(){ this.appendDummyInput().appendField('とめる'); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour(230);} };
Blockly.Blocks['pause'] = { init: function(){ this.appendDummyInput().appendField('いちじとめる'); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour(230);} };
Blockly.Blocks['resume'] = { init: function(){ this.appendDummyInput().appendField('またうごかす'); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour(230);} };

// 位置取得（出力: "x,y" 形式）
Blockly.Blocks['get_position'] = {
  init: function(){
    this.appendDummyInput().appendField('いまのばしょをしらべる');
    this.setOutput(true, null);
    this.setColour(230);
  }
};

// ---------------------- 繰り返しブロック ----------------------
Blockly.Blocks['controls_repeat_custom'] = {
  init: function() {
    this.appendValueInput("TIMES")
      .setCheck("Number")
      .appendField("つぎのことを");
    this.appendDummyInput()
      .appendField("かい くりかえす");
    this.appendStatementInput("DO")
      .appendField("すること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- 条件分岐ブロック ----------------------
Blockly.Blocks['controls_if_custom'] = {
  init: function() {
    this.appendValueInput("LEFT")
      .setCheck(null)
      .appendField("もし");
    this.appendDummyInput()
        .appendField("が")
        .appendField(new Blockly.FieldDropdown([
          ["=","EQ"],
          ["≠","NEQ"],
          [">","GT"],
          ["<","LT"],
          ["≥","GTE"],
          ["≤","LTE"]
        ]), "OP");
    this.appendValueInput("RIGHT")
        .setCheck(null);
    this.appendDummyInput()
        .appendField("なら");
    this.appendStatementInput("DO")
      .appendField("すること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Whileブロック（条件が真の間繰り返す） ----------------------
Blockly.Blocks['controls_while'] = {
  init: function() {
    this.appendValueInput("COND")
      .setCheck(null)
      .appendField("じょうけんのあいだくりかえす: じょうけん");
    this.appendStatementInput("DO")
      .appendField("すること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Repeat Until（〜になるまで繰り返す） ----------------------
Blockly.Blocks['controls_repeat_until'] = {
  init: function() {
    this.appendValueInput("COND")
      .setCheck(null)
      .appendField("じょうけんになるまでくりかえす: じょうけん");
    this.appendStatementInput("DO")
      .appendField("すること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Do-Until（最初の1回は必ず実行） ----------------------
Blockly.Blocks['controls_do_until'] = {
  init: function() {
    this.appendStatementInput("DO")
      .appendField("まず1かいする: すること");
    this.appendValueInput("COND")
      .setCheck(null)
      .appendField("つぎにじょうけんになるまでくりかえす: じょうけん");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Forever（常時実行・無限ループ） ----------------------
Blockly.Blocks['controls_forever'] = {
  init: function() {
    this.appendStatementInput('DO')
      .appendField('ずっとつづける: すること');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Try / Catch / Finally（例外処理） ----------------------
Blockly.Blocks['controls_try'] = {
  init: function() {
    this.appendStatementInput('TRY')
      .appendField('ためしてみる:');
    this.appendDummyInput()
      .appendField('エラー名:')
      .appendField(new Blockly.FieldTextInput('e'), 'ERRVAR');
    this.appendStatementInput('CATCH')
      .appendField('エラーのときのこと');
    this.appendStatementInput('FINALLY')
      .appendField('あとしまつ');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- For（インデックス付きループ） ----------------------
Blockly.Blocks['controls_for'] = {
  init: function() {
    this.appendValueInput("FROM")
      .setCheck("Number")
      .appendField("はじめ");
    this.appendValueInput("TO")
      .setCheck("Number")
      .appendField("まで");
    this.appendValueInput("BY")
      .setCheck("Number")
      .appendField("ふやしかた");
    this.appendStatementInput("DO")
      .appendField("すること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- For Each（配列/リスト走査） ----------------------
Blockly.Blocks['controls_for_each'] = {
  init: function() {
    this.appendValueInput("LIST")
      .setCheck(null)
      .appendField("リスト（,でわける）:");
    this.appendDummyInput()
      .appendField("なまえ:")
      .appendField(new Blockly.FieldTextInput("item"), "VAR");
    this.appendStatementInput("DO")
      .appendField("それぞれにすること");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Break / Continue（ループ制御） ----------------------
Blockly.Blocks['controls_break'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('ループをやめる');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

Blockly.Blocks['controls_continue'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('つぎへすすむ');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- Switch / Case / Default（多分岐） ----------------------
Blockly.Blocks['controls_switch'] = {
  init: function() {
    this.appendValueInput('VALUE')
      .setCheck(null)
      .appendField('値');
    this.appendStatementInput('DO')
      .appendField('ばあい');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

Blockly.Blocks['controls_case'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('ばあい')
      .appendField(new Blockly.FieldTextInput('値'), 'VALUE');
    this.appendStatementInput('DO')
      .appendField('すること');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

Blockly.Blocks['controls_default'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('どれにもあてはまらないとき');
    this.appendStatementInput('DO')
      .appendField('すること');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(120);
  }
};

// ---------------------- テキスト表示ブロック ----------------------
Blockly.Blocks['print_text'] = {
  init: function() {
    this.appendDummyInput()
      .appendField("みせるもじ:")
      .appendField(new Blockly.FieldTextInput("ここにかく"), "TEXT");
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(160);
  }
};

// ---------------------- 比較ブロック (採点補助) ----------------------
Blockly.Blocks['compare_values'] = {
  init: function() {
    this.appendDummyInput()
      .appendField('くらべる: ラベル')
      .appendField(new Blockly.FieldTextInput('しつもん'), 'label')
      .appendField('=')
      .appendField(new Blockly.FieldTextInput('きたいち'), 'expect');
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(200);
  }
};

// ---------------------- ワークスペース ----------------------
const workspace = Blockly.inject('blocklyDiv', {
  toolbox: document.getElementById('toolbox')
});

// 編集モードの場合、既存のBlocklyデータを読み込む
(function loadBlocklyData(){
  const blocklyXml = '{{ blockly_xml|escapejs }}';
  
  // 戻るボタン経由で戻ってきた場合は、一時保存されたBlocklyデータを優先
  const returnedFromCreate = sessionStorage.getItem('returned_from_create');
  let xmlToLoad = blocklyXml;
  
  if (returnedFromCreate === 'true') {
    const tempBlocklyXml = sessionStorage.getItem('temp_blockly_xml');
    if (tempBlocklyXml) {
      xmlToLoad = tempBlocklyXml;
      console.log('戻るボタン経由: 一時保存されたBlocklyデータを復元しました');
    }
    // 一時保存データを削除
    sessionStorage.removeItem('temp_blockly_xml');
    sessionStorage.removeItem('returned_from_create');
  }
  
  if (xmlToLoad && xmlToLoad.trim() !== '') {
    try {
      const xml = Blockly.utils.xml.textToDom(xmlToLoad);
      Blockly.Xml.domToWorkspace(xml, workspace);
    } catch(e) {
      console.error('Blocklyデータの読み込みに失敗しました:', e);
    }
  }
})();

// Undoボタン
document.getElementById('undoBtn').addEventListener('click', function() {
  workspace.undo(false);
});

// Redoボタン
document.getElementById('redoBtn').addEventListener('click', function() {
  workspace.undo(true);
});

// 保存ボタン(Blocklyワークスペースを保存して遷移)
document.getElementById('saveBtn').addEventListener('click', function() {
  // BlocklyのワークスペースをXMLに変換
  const xml = Blockly.Xml.workspaceToDom(workspace);
  const xmlText = Blockly.Xml.domToText(xml);
  
  // セッションストレージに保存
  sessionStorage.setItem('blockly_xml', xmlText);
  
  // 一時保存されたアルゴリズム名と詳細を取得（戻るボタン経由で保存された内容）
  const tempName = sessionStorage.getItem('temp_algorithm_name');
  const tempDescription = sessionStorage.getItem('temp_algorithm_description');
  const tempId = sessionStorage.getItem('temp_algorithm_id');
  
  // 編集モード対応: Django テンプレート変数からアルゴリズムIDを取得
  const existingAlgorithmData = {
    algorithmId: tempId || '{{ algorithm_id|default:"" }}',
    algorithmName: tempName || '{{ algorithm_name|default:""|escapejs }}',
    algorithmDescription: tempDescription || '{{ algorithm_description|default:""|escapejs }}'
  };
  
  // 一時保存データを削除（使い終わったので）
  sessionStorage.removeItem('temp_algorithm_name');
  sessionStorage.removeItem('temp_algorithm_description');
  sessionStorage.removeItem('temp_algorithm_id');
  
  // 編集モードの場合はIDをURLパラメータとして渡す
  if (existingAlgorithmData.algorithmId) {
    window.location.href = `/accounts/block/create/?id=${existingAlgorithmData.algorithmId}`;
  } else {
    // 新規作成の場合
    window.location.href = '/accounts/block/create/';
  }
});

// ショートカットキー（Ctrl+Z, Ctrl+Y）
document.addEventListener('keydown', function(e) {
  // Ctrl+Z（元に戻す）
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    workspace.undo(false);
  }
  // Ctrl+Y（やり直し）
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
    e.preventDefault();
    workspace.undo(true);
  }
});

// ---------------------- 条件評価関数 ----------------------
function evalCondition(block){
  if(!block) return 0;
  if(block.getValue) {
    const val = block.getValue();
    if(typeof val === "string") return val !== "" ? 1 : 0;
    return Number(val);
  }
  if(block.type === "direct_number") return Number(block.getFieldValue("value"));
  if(block.type === "arithmetic") {
    const A = evalCondition(block.getInputTargetBlock("A")) || 0;
    const B = evalCondition(block.getInputTargetBlock("B")) || 0;
    const op = block.getFieldValue("OP");
    switch(op){
      case "ADD": return A + B;
      case "MINUS": return A - B;
      case "MULTIPLY": return A * B;
      case "DIVIDE": return B !== 0 ? A / B : 0;
    }
  }
  // 追加演算の評価
  if(block.type === 'modulo'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return B !== 0 ? (A % B) : 0;
  }
  if(block.type === 'power'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.pow(A, B);
  }
  if(block.type === 'sqrt'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.sqrt(v);
  }
  if(block.type === 'abs'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.abs(v);
  }
  if(block.type === 'negate'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return -v;
  }
  if(block.type === 'round'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.round(v);
  }
  if(block.type === 'floor'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.floor(v);
  }
  if(block.type === 'ceil'){
    const v = Number(evalCondition(block.getInputTargetBlock('NUM')) || 0);
    return Math.ceil(v);
  }
  if(block.type === 'min'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.min(A,B);
  }
  if(block.type === 'max'){
    const A = Number(evalCondition(block.getInputTargetBlock('A')) || 0);
    const B = Number(evalCondition(block.getInputTargetBlock('B')) || 0);
    return Math.max(A,B);
  }
  if(block.type === 'clamp'){
    const val = Number(evalCondition(block.getInputTargetBlock('VAL')) || 0);
    const mn = Number(evalCondition(block.getInputTargetBlock('MIN')) || 0);
    const mx = Number(evalCondition(block.getInputTargetBlock('MAX')) || 0);
    if(isNaN(mn) || isNaN(mx)) return val;
    const low = Math.min(mn,mx), high = Math.max(mn,mx);
    return Math.min(Math.max(val, low), high);
  }
  if(block.type === 'random_int'){
    let mn = Number(evalCondition(block.getInputTargetBlock('MIN')) || 0);
    let mx = Number(evalCondition(block.getInputTargetBlock('MAX')) || 0);
    mn = Math.ceil(mn); mx = Math.floor(mx);
    if(mx < mn){ const t = mn; mn = mx; mx = t; }
    const range = mx - mn + 1;
    if(range <= 0) return mn;
    return Math.floor(Math.random() * range) + mn;
  }
  if(block.type === 'random_float'){
    return Math.random();
  }
  if(block.type === 'length'){
    try{
      const inBlock = block.getInputTargetBlock('INPUT');
      if(inBlock && inBlock.getValue){
        const v = inBlock.getValue();
        if(Array.isArray(v)) return v.length;
        if(typeof v === 'string') return v.length;
        if(typeof v === 'number') return String(v).length;
      }
      // fallback: evaluate nested block
      const maybe = evalCondition(inBlock);
      if(Array.isArray(maybe)) return maybe.length;
      if(typeof maybe === 'string') return maybe.length;
      if(typeof maybe === 'number') return String(maybe).length;
    }catch(e){/* ignore */}
    return 0;
  }
  if(block.type === 'date_add_days'){
    try{
      const dateBlock = block.getInputTargetBlock('DATE');
      let baseDate = null;
      if(dateBlock){
        // try getValue() from form-like blocks
        if(typeof dateBlock.getValue === 'function'){
          const gv = dateBlock.getValue();
          if(typeof gv === 'string' && gv.trim() !== '') baseDate = new Date(gv);
          else if(typeof gv === 'number') baseDate = new Date(gv);
        }
        if(!baseDate){
          try{
            const txt = dateBlock.getFieldValue && (dateBlock.getFieldValue('value') || dateBlock.getFieldValue('label') || dateBlock.getFieldValue('TEXT') || '');
            if(txt) baseDate = new Date(txt);
          }catch(e){}
        }
        if(!baseDate){
          const num = evalCondition(dateBlock);
          if(typeof num === 'number' && !isNaN(num)){
            if(num > 1e11) baseDate = new Date(num);
            else {
              const s = String(num);
              if(s.length === 8){
                const y = Number(s.slice(0,4)), m = Number(s.slice(4,6))-1, d = Number(s.slice(6,8));
                baseDate = new Date(y,m,d);
              } else {
                baseDate = new Date(num);
              }
            }
          }
        }
      }
      if(!baseDate || isNaN(baseDate.getTime())) baseDate = new Date();
      const days = Number(evalCondition(block.getInputTargetBlock('DAYS')) || 0);
      const result = new Date(baseDate.getTime() + days * 24 * 60 * 60 * 1000);
      const y = result.getFullYear();
      const m = String(result.getMonth()+1).padStart(2,'0');
      const d = String(result.getDate()).padStart(2,'0');
      return `${y}-${m}-${d}`;
    }catch(e){ return ''; }
  }
  // get_position: return current actor position as "x,y"
  if(block.type === 'get_position'){
    try{
      const a = window._actor || {x:0,y:0};
      return `${a.x},${a.y}`;
    }catch(e){ return '0,0'; }
  }
  return 0;
}

function evalIfCondition(block){
  if(!block) return false;
  const left = evalCondition(block.getInputTargetBlock("LEFT"));
  const right = evalCondition(block.getInputTargetBlock("RIGHT"));
  const op = block.getFieldValue("OP");
  switch(op){
    case "EQ": return left == right;
    case "NEQ": return left != right;
    case "GT": return left > right;
    case "LT": return left < right;
    case "GTE": return left >= right;
    case "LTE": return left <= right;
  }
  return false;
}

// Collect answers rendered in #visual-area: label -> value
function collectAnswers(){
  const pairs = {};
  try{
    const rows = Array.from(document.querySelectorAll('#visual-area .form-row'));
    rows.forEach(row => {
      // Determine label robustly: prefer <label for="...">, then leading text node, then any <label>
      let label = '';
      const labelFor = row.querySelector('label[for]');
      if(labelFor) label = labelFor.innerText.trim();
      if(!label){
        // look for leading text node (used by radio_choice and others)
        for(const node of row.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            const t = node.textContent.trim();
            if(t){ label = t; break; }
          }
          // if it's an element and not an input/label, try its text
          if(node.nodeType === Node.ELEMENT_NODE && !['INPUT','LABEL'].includes(node.tagName)){
            const t = node.textContent.trim(); if(t){ label = t; break; }
          }
        }
      }
      if(!label){
        const anyLabel = row.querySelector('label');
        if(anyLabel) label = anyLabel.innerText.trim();
      }
      if(!label) label = (row.dataset.label || '').trim();
      if(!label) return;

      // Collect value by input type
      const inputText = row.querySelector('input[type="text"], textarea');
      if(inputText){ pairs[label] = inputText.value; return; }
      const inputNumber = row.querySelector('input[type="number"]');
      if(inputNumber){ pairs[label] = inputNumber.value; return; }
      const inputFile = row.querySelector('input[type="file"]');
      if(inputFile){
        const files = inputFile.files;
        if(files && files.length){
          pairs[label] = Array.from(files).map(f=>f.name).join(', ');
        } else {
          pairs[label] = '';
        }
        return;
      }
      const radios = row.querySelectorAll('input[type="radio"]');
      if(radios && radios.length){
        const name = radios[0].name;
        const checked = row.querySelector(`input[name="${name}"]:checked`);
        pairs[label] = checked ? checked.value : '';
        return;
      }
      const checkboxes = row.querySelectorAll('input[type="checkbox"]');
      if(checkboxes && checkboxes.length){
        const vals = Array.from(checkboxes).filter(c=>c.checked).map(c=>c.value);
        pairs[label] = vals.join(',');
        return;
      }
      // fallback: take visible text
      pairs[label] = row.innerText.replace(/\n/g,' ').trim();
    });
  }catch(e){ console.error('collectAnswers error', e); }
  return pairs;
}

// ---------------------- 実行関数 ----------------------
function runBlocks(){
  visual.innerHTML = "";
  const blocks = workspace.getTopBlocks(true);

  function processBlock(block){
    if(!block) return;

    if(block.updateVisual) block.updateVisual(visual);
    else{
      switch(block.type){
        case 'controls_repeat_custom':
          const times = evalCondition(block.getInputTargetBlock("TIMES")) || 0;
          const doBlock = block.getInputTargetBlock("DO");
          for(let i = 0; i < times; i++){
            if(doBlock){
              try{ processBlock(doBlock); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { continue; }
                if(ctrl && ctrl.control === 'break') { break; }
                throw ctrl;
              }
            }
          }
          break;

        case 'controls_if_custom':
          if(evalIfCondition(block)){
            const doBlock = block.getInputTargetBlock("DO");
            if(doBlock) processBlock(doBlock);
          }
          break;

        case 'controls_while':
          try{
            const condBlock = block.getInputTargetBlock("COND");
            const doBlock = block.getInputTargetBlock("DO");
            // 安全策: 無限ループ防止のため最大反復回数を設ける
            const MAX_ITER = 1000;
            let iter = 0;
            while((evalCondition(condBlock) || 0) !== 0){
              if(!doBlock) break;
              try{ processBlock(doBlock); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iter++;
              if(iter >= MAX_ITER){
                visual.innerHTML += `<div class="form-row">(ループが最大反復 ${MAX_ITER} に達しました — 無限ループを防止して停止)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_while error', e); }
          break;

        case 'controls_repeat_until':
          try{
            const condBlockRU = block.getInputTargetBlock("COND");
            const doBlockRU = block.getInputTargetBlock("DO");
            const MAX_ITER_RU = 1000;
            let iterRU = 0;
            // 条件が真になるまで繰り返す -> 条件が偽の間ループ
            while(((evalCondition(condBlockRU) || 0) === 0)){
              if(!doBlockRU) break;
              try{ processBlock(doBlockRU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iterRU++;
              if(iterRU >= MAX_ITER_RU){
                visual.innerHTML += `<div class="form-row">(Repeat Until: 反復が最大 ${MAX_ITER_RU} に達しました — 停止)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_repeat_until error', e); }
          break;

        case 'controls_do_until':
          try{
            const doBlockDU = block.getInputTargetBlock("DO");
            const condBlockDU = block.getInputTargetBlock("COND");
            const MAX_ITER_DU = 1000;
            let iterDU = 0;
            // 最低1回は実行してから条件を評価
            if(doBlockDU){
              try{ processBlock(doBlockDU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* continue to condition check */ }
                else if(ctrl && ctrl.control === 'break') { /* break outer do-until */ return; }
                else throw ctrl;
              }
            }
            while(((evalCondition(condBlockDU) || 0) === 0)){
              if(!doBlockDU) break;
              try{ processBlock(doBlockDU); }
              catch(ctrl){
                if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                else if(ctrl && ctrl.control === 'break') { break; }
                else throw ctrl;
              }
              iterDU++;
              if(iterDU >= MAX_ITER_DU){
                visual.innerHTML += `<div class="form-row">(Do-Until: 反復が最大 ${MAX_ITER_DU} に達しました — 停止)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_do_until error', e); }
          break;

        case 'controls_for':
          try{
            const fromBlock = block.getInputTargetBlock("FROM");
            const toBlock = block.getInputTargetBlock("TO");
            const byBlock = block.getInputTargetBlock("BY");
            const doBlockF = block.getInputTargetBlock("DO");
            let from = Number(evalCondition(fromBlock) || 0);
            let to = Number(evalCondition(toBlock) || 0);
            let by = Number(evalCondition(byBlock) || 1);
            if(by === 0) by = 1; // 増分0は避ける

            const MAX_ITER_F = 10000;
            let iterF = 0;

            // ループ方向に応じて条件を判定
            const forward = by > 0;
            // expose current index to potential custom blocks via global (将来的に専用ブロックで取得可能)
            if(typeof window._for_index === 'undefined') window._for_index = null;

            if(forward){
              for(let i = from; i <= to; i += by){
                window._for_index = i;
                if(doBlockF){
                  try{ processBlock(doBlockF); }
                  catch(ctrl){
                    if(ctrl && ctrl.control === 'continue') { continue; }
                    if(ctrl && ctrl.control === 'break') { break; }
                    throw ctrl;
                  }
                }
                iterF++;
                if(iterF >= MAX_ITER_F){
                  visual.innerHTML += `<div class="form-row">(For: 反復が最大 ${MAX_ITER_F} に達しました — 停止)</div>`;
                  break;
                }
              }
            } else {
              for(let i = from; i >= to; i += by){
                window._for_index = i;
                if(doBlockF){
                  try{ processBlock(doBlockF); }
                  catch(ctrl){
                    if(ctrl && ctrl.control === 'continue') { continue; }
                    if(ctrl && ctrl.control === 'break') { break; }
                    throw ctrl;
                  }
                }
                iterF++;
                if(iterF >= MAX_ITER_F){
                  visual.innerHTML += `<div class="form-row">(For: 反復が最大 ${MAX_ITER_F} に達しました — 停止)</div>`;
                  break;
                }
              }
            }
            window._for_index = null;
          }catch(e){ console.error('controls_for error', e); }
          break;

        case 'controls_forever':
          try{
            const doBlockForever = block.getInputTargetBlock('DO');
            const MAX_FOREVER = 100000;
            let iterFv = 0;
            while(true){
              if(doBlockForever){
                try{ processBlock(doBlockForever); }
                catch(ctrl){
                  if(ctrl && ctrl.control === 'continue') { /* next iteration */ }
                  else if(ctrl && ctrl.control === 'break') { break; }
                  else throw ctrl;
                }
              }
              iterFv++;
              if(iterFv >= MAX_FOREVER){
                visual.innerHTML += `<div class="form-row">(Forever: 反復が最大 ${MAX_FOREVER} に達しました — 停止)</div>`;
                break;
              }
            }
          }catch(e){ console.error('controls_forever error', e); }
          break;

        case 'controls_for_each':
          try{
            const listBlock = block.getInputTargetBlock("LIST");
            const varName = block.getFieldValue("VAR") || 'item';
            const doBlockFE = block.getInputTargetBlock("DO");

            function resolveList(lb){
              if(!lb) return [];
              // If block provides a getValue() (form blocks), use it
              if(lb.getValue){
                try{
                  const v = lb.getValue();
                  if(Array.isArray(v)) return v;
                  if(typeof v === 'string') return v.split(',').map(s=>s.trim()).filter(s=>s!=='');
                  if(typeof v === 'number') return [v];
                }catch(e){ /* ignore */ }
              }
              // If it's a direct number or arithmetic, evaluate as number
              if(lb.type === 'direct_number' || lb.type === 'arithmetic'){
                const n = evalCondition(lb);
                return [n];
              }
              // Fallback: try evalCondition (may return number)
              const maybe = evalCondition(lb);
              if(typeof maybe === 'number' && !isNaN(maybe)) return [maybe];
              // If lb has a field 'value' (rare), read it
              try{
                const f = lb.getFieldValue && lb.getFieldValue('value');
                if(typeof f === 'string') return f.split(',').map(s=>s.trim()).filter(s=>s!=='');
              }catch(e){}
              return [];
            }

            const items = resolveList(listBlock);
            const MAX_FE = 10000;
            let iterFE = 0;
            if(typeof window._for_each_item === 'undefined') window._for_each_item = null;
            if(typeof window._for_each_index === 'undefined') window._for_each_index = null;
            if(typeof window._vars === 'undefined') window._vars = {};

            for(let idx = 0; idx < items.length; idx++){
              window._for_each_index = idx;
              window._for_each_item = items[idx];
              // expose variable name for potential use blocks
              window._vars[varName] = items[idx];
              if(doBlockFE){
                try{ processBlock(doBlockFE); }
                catch(ctrl){
                  if(ctrl && ctrl.control === 'continue') { /* next item */ continue; }
                  if(ctrl && ctrl.control === 'break') { break; }
                  throw ctrl;
                }
              }
              iterFE++;
              if(iterFE >= MAX_FE){
                visual.innerHTML += `<div class="form-row">(ForEach: 反復が最大 ${MAX_FE} に達しました — 停止)</div>`;
                break;
              }
            }
            // cleanup
            window._for_each_item = null;
            window._for_each_index = null;
            delete window._vars[varName];
          }catch(e){ console.error('controls_for_each error', e); }
          break;

        case 'controls_switch':
          try{
            const valBlock = block.getInputTargetBlock('VALUE');
            const switchValRaw = (function(){
              // try numeric evaluation first
              const num = evalCondition(valBlock);
              if(typeof num === 'number' && !isNaN(num) && String(num) !== '0') return num;
              // if evalCondition returned 0, it could be falsy for strings; try fieldValue
              try{
                if(valBlock && valBlock.getFieldValue){
                  const f = valBlock.getFieldValue('value') || valBlock.getFieldValue('label') || valBlock.getFieldValue('TEXT') || valBlock.getFieldValue('VALUE');
                  if(typeof f === 'string') return f;
                }
              }catch(e){}
              return num;
            })();

            let matched = false;
            let executed = false;
            let caseBlock = block.getInputTargetBlock('DO');
            // iterate case/default blocks linked under DO
            while(caseBlock){
              if(caseBlock.type === 'controls_case'){
                const caseVal = caseBlock.getFieldValue('VALUE');
                // compare: numeric vs numeric or string vs string
                let isMatch = false;
                // numeric compare when both numeric
                if(!isNaN(Number(switchValRaw)) && !isNaN(Number(caseVal))){
                  isMatch = Number(switchValRaw) === Number(caseVal);
                } else {
                  const a = (switchValRaw===null||switchValRaw===undefined)?'':String(switchValRaw).trim();
                  const b = (caseVal===null||caseVal===undefined)?'':String(caseVal).trim();
                  // remove surrounding quotes if present
                  const strip = s => (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'")) ? s.slice(1,-1) : s;
                  isMatch = strip(a) === strip(b);
                }

                if(isMatch){
                  // execute case body and then stop unless break/continue control is used
                  const body = caseBlock.getInputTargetBlock('DO');
                  if(body){
                    try{ processBlock(body); }
                    catch(ctrl){
                      if(ctrl && ctrl.control === 'continue') { /* continue to next case */ }
                      else if(ctrl && ctrl.control === 'break') { executed = true; matched = true; break; }
                      else throw ctrl;
                    }
                    executed = true; matched = true; break;
                  } else { matched = true; break; }
                }
              } else if(caseBlock.type === 'controls_default'){
                // default runs if no previous match
                if(!matched){
                  const body = caseBlock.getInputTargetBlock('DO');
                  if(body){
                    try{ processBlock(body); }
                    catch(ctrl){
                      if(ctrl && ctrl.control === 'continue') { /* no-op */ }
                      else if(ctrl && ctrl.control === 'break') { executed = true; break; }
                      else throw ctrl;
                    }
                    executed = true; break;
                  }
                }
              }
              caseBlock = caseBlock.getNextBlock();
            }
          }catch(e){ console.error('controls_switch error', e); }
          break;

          case 'controls_try':
            try{
              const tryBlock = block.getInputTargetBlock('TRY');
              const catchBlock = block.getInputTargetBlock('CATCH');
              const finallyBlock = block.getInputTargetBlock('FINALLY');
              const errVar = (block.getFieldValue && block.getFieldValue('ERRVAR')) || '';
              try{
                if(tryBlock) processBlock(tryBlock);
              }catch(err){
                // loop control signals (break/continue) should propagate
                if(err && err.control) throw err;
                // expose caught exception
                try{ window._last_exception = err; }catch(e){}
                if(errVar && typeof window._vars === 'undefined') window._vars = {};
                if(errVar) window._vars[errVar] = err;
                if(catchBlock) {
                  try{ processBlock(catchBlock); }
                  catch(ctrl){
                    // if catch body raises loop control, propagate
                    if(ctrl && ctrl.control) throw ctrl;
                    else throw ctrl;
                  }
                } else {
                  visual.innerHTML += `<div class="form-row">(例外捕捉) ${String(err)}</div>`;
                }
                if(errVar) delete window._vars[errVar];
              } finally {
                // always run finally block
                if(finallyBlock){
                  try{ processBlock(finallyBlock); }
                  catch(ctrl){
                    if(ctrl && ctrl.control) throw ctrl;
                    else throw ctrl;
                  }
                }
                try{ delete window._last_exception; }catch(e){}
              }
            }catch(e){ console.error('controls_try error', e); }
            break;

        case 'print_text':
          const textVal = block.getFieldValue("TEXT");
          visual.innerHTML += `<p>${textVal}</p>`;
          break;

        case 'controls_break':
          throw { control: 'break' };

        case 'controls_continue':
          throw { control: 'continue' };

        case 'compare_values':
          try{
            const label = block.getFieldValue('label') || '';
            const expect = String(block.getFieldValue('expect') || '');
            const answers = collectAnswers();
            // If there's a rendered answer for this label, use it. Otherwise treat the label itself as a literal value (allow comparing two literals).
            let actual = '';
            if(Object.prototype.hasOwnProperty.call(answers, label)){
              actual = String(answers[label]);
            } else {
              // fallback: if label looks like a number, use it; if quoted string, unquote; otherwise use label as-is
              const trimmed = label.trim();
              if(/^[-+]?\d+(?:\.\d+)?$/.test(trimmed)){
                actual = trimmed;
              } else if((trimmed.startsWith('"') && trimmed.endsWith('"')) || (trimmed.startsWith("'") && trimmed.endsWith("'"))){
                actual = trimmed.slice(1,-1);
              } else {
                actual = trimmed;
              }
            }

            const eqNumeric = !isNaN(Number(actual)) && !isNaN(Number(expect)) && Number(actual) === Number(expect);
            const eqString = typeof actual === 'string' && typeof expect === 'string' && actual.trim().toLowerCase() === expect.trim().toLowerCase();
            const ok = (actual === expect) || eqNumeric || eqString;

            visual.innerHTML += `<div class="form-row">${label}: ${actual} → <strong>${ok? '正解':'不正解'}</strong></div>`;
            const row = Array.from(document.querySelectorAll('#visual-area .form-row')).find(r=>{
              const l = r.querySelector('label'); return l && l.innerText.trim() === label;
            });
            if(row) row.style.outline = ok ? '2px solid #4caf50' : '2px solid #e53935';
          }catch(e){ console.error('compare_values error', e); }
          break;

        case 'radio_choice':
        case 'radio_free':
        case 'checkbox_free':
        case 'number_input':
        case 'show_text':
          const val = block.getValue?.();
          if(val !== undefined && val !== null && val !== "") {
            visual.innerHTML += `<p>${val}</p>`;
          }
          break;

        case 'move_steps':
          visual.innerHTML += `<p>${block.getFieldValue('steps')}歩動かす</p>`; break;
        case 'turn_right':
          visual.innerHTML += `<p>${block.getFieldValue('degrees')}度右に回す</p>`; break;
        case 'turn_left':
          visual.innerHTML += `<p>${block.getFieldValue('degrees')}度左に回す</p>`; break;
        case 'goto_xy':
          // 即時テレポート的に位置をセット
          try{
            const tx = Number(block.getFieldValue('x') || 0);
            const ty = Number(block.getFieldValue('y') || 0);
            if(window._actor.stopped){ visual.innerHTML += `<p>(停止中) テレポートは実行されません</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(一時停止中) テレポートは保留されます</p>`; break; }
            const prevX = window._actor.x, prevY = window._actor.y;
            const dx = tx - prevX, dy = ty - prevY;
            const dist = Math.hypot(dx,dy);
            // update position immediately; simulate elapsed time based on speed if speed>0
            const duration = window._actor.speed > 0 ? (dist / window._actor.speed) : 0;
            window._actor.x = tx; window._actor.y = ty; window._actor.simTime += duration;
            visual.innerHTML += `<p>座標を (${tx}, ${ty}) にする — 距離 ${dist.toFixed(2)}、経過 ${duration.toFixed(2)}s</p>`;
          }catch(e){ visual.innerHTML += `<p>座標設定エラー</p>`; }
          break;

        case 'move_relative':
          try{
            if(window._actor.stopped){ visual.innerHTML += `<p>(停止中) 移動は実行されません</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(一時停止中) 移動は保留されます</p>`; break; }
            const dx = Number(block.getFieldValue('dx') || 0);
            const dy = Number(block.getFieldValue('dy') || 0);
            const prevX = window._actor.x, prevY = window._actor.y;
            window._actor.x = prevX + dx; window._actor.y = prevY + dy;
            const dist = Math.hypot(dx,dy);
            const duration = window._actor.speed > 0 ? (dist / window._actor.speed) : 0;
            window._actor.simTime += duration;
            visual.innerHTML += `<p>相対移動 dx:${dx} dy:${dy} → 新座標 (${window._actor.x}, ${window._actor.y}) 経過 ${duration.toFixed(2)}s</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'move_to_duration':
          try{
            if(window._actor.stopped){ visual.innerHTML += `<p>(停止中) 移動は実行されません</p>`; break; }
            if(window._actor.paused){ visual.innerHTML += `<p>(一時停止中) 移動は保留されます</p>`; break; }
            const tx = Number(block.getFieldValue('x') || 0);
            const ty = Number(block.getFieldValue('y') || 0);
            const dur = Number(block.getFieldValue('duration') || 0) || 0;
            const prevX = window._actor.x, prevY = window._actor.y;
            const dist = Math.hypot(tx - prevX, ty - prevY);
            // simulate: set position immediately but account for duration in simTime
            window._actor.x = tx; window._actor.y = ty; window._actor.simTime += dur;
            const impliedSpeed = dur > 0 ? (dist / dur) : 0;
            visual.innerHTML += `<p>滑らかに移動 to (${tx},${ty}) 所要 ${dur}s (距離 ${dist.toFixed(2)}、速さ ${impliedSpeed.toFixed(2)})</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'set_speed':
          try{
            const sp = Number(block.getFieldValue('speed') || 1);
            window._actor.speed = sp;
            visual.innerHTML += `<p>速度を ${sp} に設定しました</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'wait_seconds':
          try{
            const s = Number(block.getFieldValue('secs') || 0);
            window._actor.simTime += s;
            visual.innerHTML += `<p>待機: ${s} 秒（擬似）</p>`;
          }catch(e){ console.error(e); }
          break;

        case 'stop':
          window._actor.stopped = true; window._actor.paused = false;
          visual.innerHTML += `<p>停止: すべての移動が無効化されます</p>`;
          break;

        case 'pause':
          window._actor.paused = true;
          visual.innerHTML += `<p>一時停止: 動作は保留されます</p>`;
          break;

        case 'resume':
          window._actor.paused = false;
          visual.innerHTML += `<p>再開: 保留中の動作は再開されます（停止は解除されません）</p>`;
          break;

        case 'get_position':
          try{
            const a = window._actor || {x:0,y:0};
            visual.innerHTML += `<p>現在位置: (${a.x}, ${a.y})</p>`;
          }catch(e){ }
          break;
        case 'direct_number':
        case 'arithmetic':
        case 'modulo':
        case 'power':
        case 'sqrt':
        case 'abs':
        case 'negate':
        case 'round':
        case 'floor':
        case 'ceil':
        case 'min':
        case 'max':
        case 'clamp':
        case 'random_int':
        case 'random_float':
        case 'length':
        case 'date_add_days':
          visual.innerHTML += `<p>演算結果: ${evalCondition(block)}</p>`; break;
      }
    }

    const next = block.getNextBlock();
    if(next) processBlock(next);
  }

  blocks.forEach(b => processBlock(b));
}

visual.innerHTML = "ここに実行結果が表示されます";

// 未保存の変更を追跡
let isDirty = false;
let initialContent = '';

// 初期状態を保存
(function saveInitialState(){
  const slideArea = document.getElementById('slideArea');
  if (slideArea) {
    initialContent = slideArea.innerHTML;
  }
})();

// 変更を検知する関数
function markDirty() {
  const slideArea = document.getElementById('slideArea');
  if (slideArea && slideArea.innerHTML !== initialContent) {
    isDirty = true;
  }
}

// スライドエリアの変更を監視
(function watchChanges(){
  const slideArea = document.getElementById('slideArea');
  if (!slideArea) return;
  
  // MutationObserverで変更を監視
  const observer = new MutationObserver(function() {
    markDirty();
  });
  
  observer.observe(slideArea, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true
  });
})();

// ブラウザ閉じる/リロード時の警告
window.addEventListener('beforeunload', function(e) {
  if (!isDirty) return;
  e.preventDefault();
  e.returnValue = '';
});

// ナビゲーションタブクリック時の警告
(function handleNavigation(){
  const tabs = document.querySelectorAll('.top-tabs a[id^="tab-"]');
  tabs.forEach(tab => {
    tab.addEventListener('click', function(e) {
      // アルゴリズムタブ自身のクリックは許可
      if (this.id === 'tab-algorithms') return;
      
      if (isDirty) {
        e.preventDefault();
        const confirmed = confirm('保存されていない変更があります。移動してもよろしいですか？');
        if (confirmed) {
          isDirty = false;
          window.location.href = this.href;
        }
      }
    });
  });
})();

// 保存時にisDirtyをリセット
const originalSaveBtn = document.getElementById('saveBtn');
if (originalSaveBtn) {
  originalSaveBtn.addEventListener('click', function() {
    isDirty = false;
  });
}

// ナビゲーションバーでアルゴリズムタブをアクティブに設定
(function setActiveTab(){
  const algorithmTab = document.getElementById('tab-algorithms');
  if (algorithmTab) {
    algorithmTab.classList.add('active');
  }
})();

// ナビゲーションバーとフィールドの重なりを検出して非表示にする
(function handleNavbarOverlap(){
  const navbar = document.querySelector('.top-tabs');
  const container = document.getElementById('container');
  
  if (!navbar || !container) return;
  
  function checkOverlap() {
    const navbarRect = navbar.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // ナビゲーションバーとコンテナが重なっているかチェック
    const isOverlapping = !(
      navbarRect.bottom < containerRect.top ||
      navbarRect.top > containerRect.bottom ||
      navbarRect.right < containerRect.left ||
      navbarRect.left > containerRect.right
    );
    
    if (isOverlapping) {
      navbar.classList.add('hidden');
    } else {
      navbar.classList.remove('hidden');
    }
  }
  
  // スクロール時とリサイズ時にチェック
  window.addEventListener('scroll', checkOverlap);
  window.addEventListener('resize', checkOverlap);
  
  // 初回チェック
  checkOverlap();
})();
</script>
{% endblock %}