<script>
// ========================================
// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ï¼ˆå®Ÿè¡Œç”»é¢ï¼‰æ©Ÿèƒ½
// ========================================

window.openPreview = function openPreview(){
  if (document.getElementById('previewOverlay')) return;
  const original = document.getElementById('slideArea');
  if (!original) return;

  const overlay = document.createElement('div');
  overlay.id = 'previewOverlay';
  overlay.className = 'preview-overlay';
  overlay.setAttribute('role','dialog');
  overlay.setAttribute('aria-modal','true');

  const header = document.createElement('div');
  header.className = 'preview-header';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'preview-close';
  closeBtn.textContent = 'é–‰ã˜ã‚‹ (Esc)';
  closeBtn.setAttribute('aria-label','é–‰ã˜ã‚‹');
  header.appendChild(closeBtn);

  const areaWrap = document.createElement('div');
  areaWrap.className = 'preview-area';

  const clone = original.cloneNode(true);
  clone.id = 'previewSlideArea';
  const trash = clone.querySelector('#trash');
  if (trash) trash.remove();

  // cloneNode(true)ã¯DOMæ§‹é€ ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŒã€input/textareaã®ç¾åœ¨å€¤ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„
  // æ˜ç¤ºçš„ã«å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
  const originalInputs = original.querySelectorAll('input, textarea');
  const clonedInputs = clone.querySelectorAll('input, textarea');
  originalInputs.forEach((originalInput, index) => {
    if (clonedInputs[index]) {
      clonedInputs[index].value = originalInput.value;
    }
  });

  clone.querySelectorAll('input,textarea').forEach(el => {
    try {
      el.style.resize = 'none';
    } catch(e){}
  });
  clone.querySelectorAll('input[data-only-number="true"]').forEach(inp=>{
    try { attachNumberFilter(inp); } catch(e){ console.error(e); }
  });

  clone.querySelectorAll('.text-input, [contenteditable]').forEach(el => {
    try {
      if (el.classList && el.classList.contains('text-input')) {
        el.setAttribute('contenteditable','false');
      } else {
        el.setAttribute('contenteditable','false');
      }
    } catch(e){}
  });

  clone.querySelectorAll('.drag-handle').forEach(h => h.remove());

  clone.querySelectorAll('.timer-settings-btn').forEach(el => {
    el.style.display = 'none';
  });

  const previewStyle = document.createElement('style');
  previewStyle.textContent = `
    #previewSlideArea * { pointer-events: none !important; }
    #previewSlideArea button,
    #previewSlideArea .draggable-btn,
    #previewSlideArea .timer-btn { pointer-events: auto !important; }
    #previewSlideArea input,
    #previewSlideArea textarea,
    #previewSlideArea .input-box { pointer-events: auto !important; }
    #previewSlideArea .text-input,
    #previewSlideArea .text-input-container { pointer-events: none !important; }
    #previewSlideArea .input-container,
    #previewSlideArea .draggable-btn,
    #previewSlideArea .text-input-container,
    #previewSlideArea .checkbox-group,
    #previewSlideArea .radio-group,
    #previewSlideArea .timer-container { user-select: text !important; }
    #previewSlideArea .input-label,
    #previewSlideArea .text-input,
    #previewSlideArea input,
    #previewSlideArea textarea { outline: none !important; box-shadow: none !important; }
    #previewSlideArea { -webkit-user-select: text !important; user-select: text !important; box-shadow: 0 6px 30px rgba(0,0,0,0.24); }
    #previewSlideArea .timer-settings-btn { display: none !important; }
    #previewSlideArea .checkbox-group-label { display: none !important; }
    #previewSlideArea .radio-group-label { display: none !important; }
  `;
  overlay.appendChild(previewStyle);

  clone.querySelectorAll('button, .draggable-btn').forEach(btn => {
    try {
      if (!btn.classList.contains('timer-btn') && !btn.classList.contains('timer-mode-btn')) {
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        const targetSystemId = newBtn.getAttribute('data-target-system');
        const algorithmId = newBtn.getAttribute('data-algorithm-id');
        const algorithmXml = newBtn.getAttribute('data-algorithm-xml');
        
        console.log('ğŸ”§ ãƒœã‚¿ãƒ³è¨­å®š:', {
          text: newBtn.textContent,
          systemId: targetSystemId,
          algorithmId: algorithmId,
          hasXml: !!algorithmXml,
          xmlLength: algorithmXml ? algorithmXml.length : 0
        });
        
        newBtn.addEventListener('click', async function(e){
          e.stopPropagation();
          
          console.log('ğŸ–±ï¸ ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯:', newBtn.textContent);
          
          if (algorithmId && algorithmXml) {
            console.log('â–¶ï¸ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–‹å§‹:', algorithmId);
            await executeAlgorithmFromButton(algorithmXml, newBtn.textContent);
          } else if (targetSystemId) {
            console.log('ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ é·ç§»:', targetSystemId);
            loadSystemInPreview(targetSystemId);
          } else {
            console.log('âš ï¸ ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ - å‹•ä½œãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          }
        });
      }
    } catch(err) {
      console.error('ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šã‚¨ãƒ©ãƒ¼:', err);
    }
  });

  clone.querySelectorAll('.timer-container').forEach(timer => {
    const startBtn = timer.querySelector('.timer-btn.start');
    const resetBtn = timer.querySelector('.timer-btn.reset');
    const display = timer.querySelector('.timer-display');
    
    if (startBtn) {
      startBtn.onclick = function(e) {
        e.stopPropagation();
        const running = timer.getAttribute('data-timer-running') === 'true';
        const mode = timer.getAttribute('data-timer-mode');
        
        if (!running) {
          if (mode === 'down') {
            const target = parseInt(timer.getAttribute('data-timer-target') || '0');
            if (target === 0) {
              alert('ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã®æ™‚é–“ã‚’è¨­å®šã—ã¦ãã ã•ã„');
              return;
            }
          }
          timer.setAttribute('data-timer-running', 'true');
          startBtn.textContent = "åœæ­¢";
          startBtn.classList.remove('start');
          startBtn.classList.add('pause');
        } else {
          timer.setAttribute('data-timer-running', 'false');
          startBtn.textContent = "é–‹å§‹";
          startBtn.classList.remove('pause');
          startBtn.classList.add('start');
        }
      };
    }
    
    if (resetBtn) {
      resetBtn.onclick = function(e) {
        e.stopPropagation();
        const mode = timer.getAttribute('data-timer-mode');
        timer.setAttribute('data-timer-running', 'false');
        
        if (mode === 'up') {
          timer.setAttribute('data-timer-seconds', '0');
          if (display) display.textContent = "00:00:00";
        } else {
          const target = parseInt(timer.getAttribute('data-timer-target') || '0');
          timer.setAttribute('data-timer-seconds', target.toString());
          if (display) {
            const h = Math.floor(target / 3600);
            const m = Math.floor((target % 3600) / 60);
            const s = target % 60;
            display.textContent = 
              String(h).padStart(2, '0') + ':' +
              String(m).padStart(2, '0') + ':' +
              String(s).padStart(2, '0');
          }
        }
        
        if (startBtn) {
          startBtn.textContent = "é–‹å§‹";
          startBtn.classList.remove('pause');
          startBtn.classList.add('start');
        }
      };
    }
  });

  areaWrap.appendChild(clone);
  
  // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ IDã‚’è¨­å®šï¼ˆç·¨é›†ç”»é¢ã§é–‹ã„ã¦ã„ã‚‹ã‚·ã‚¹ãƒ†ãƒ ï¼‰
  if (existingSystemData && existingSystemData.systemId) {
    clone.dataset.currentSystemId = existingSystemData.systemId;
  }
  
  overlay.appendChild(header);
  overlay.appendChild(areaWrap);
  document.body.appendChild(overlay);

  const prevOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';

  function closeOverlay(){
    try{ overlay.remove(); }catch(err){}
    document.body.style.overflow = prevOverflow || '';
  }
  closeBtn.addEventListener('click', closeOverlay);
  overlay.addEventListener('click', function(evt){
    if (evt.target === overlay) closeOverlay();
  });
  document.addEventListener('keydown', function onEsc(e){
    if (e.key === 'Escape') {
      closeOverlay();
      document.removeEventListener('keydown', onEsc);
    }
  });
}

// ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè¡Œç”»é¢ã«èª­ã¿è¾¼ã‚€é–¢æ•°
window.loadSystemInPreview = async function loadSystemInPreview(systemId) {
  try {
    console.log(`ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ã‚’èª­ã¿è¾¼ã¿ä¸­...`);
    
    // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ IDã‚’å–å¾—
    const previewArea = document.getElementById('previewSlideArea');
    const currentSystemId = previewArea?.dataset?.currentSystemId;
    
    // åŒã˜ã‚·ã‚¹ãƒ†ãƒ ã‚’å†èª­ã¿è¾¼ã¿ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å ´åˆã¯è­¦å‘Šï¼ˆå…¥åŠ›å€¤ãŒå¤±ã‚ã‚Œã‚‹ï¼‰
    if (currentSystemId && currentSystemId === systemId) {
      console.warn(`âš ï¸ ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ ï¼ˆID: ${systemId}ï¼‰ã‚’å†èª­ã¿è¾¼ã¿ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚å…¥åŠ›å€¤ãŒå¤±ã‚ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`);
    }
    
    const response = await fetch(`/accounts/system/elements/?system_id=${systemId}`);
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚·ã‚¹ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
      } else if (response.status === 401) {
        throw new Error('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
      } else {
        throw new Error(`ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})`);
      }
    }
    
    const data = await response.json();
    console.log('ğŸ“¦ å—ä¿¡ãƒ‡ãƒ¼ã‚¿:', data);
    
    if (!data.success) {
      throw new Error(data.error || 'ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    // previewAreaã¯æ—¢ã«ä¸Šã§å–å¾—æ¸ˆã¿ï¼ˆ236è¡Œç›®ï¼‰ãªã®ã§å†å®£è¨€ä¸è¦
    if (!previewArea) {
      console.error('å®Ÿè¡Œç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      return;
    }
    
    const children = Array.from(previewArea.children);
    children.forEach(child => {
      if (child.id !== 'trash') {
        child.remove();
      }
    });
    
    // èª­ã¿è¾¼ã‚“ã ã‚·ã‚¹ãƒ†ãƒ ã®IDã‚’è¨˜éŒ²
    previewArea.dataset.currentSystemId = systemId;
    
    restoreSystemElementsToPreview(data.elements, previewArea);
    console.log(`âœ… ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ã®èª­ã¿è¾¼ã¿å®Œäº†`);
    
  } catch (error) {
    console.error('âŒ ã‚·ã‚¹ãƒ†ãƒ ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
    alert('ã‚·ã‚¹ãƒ†ãƒ ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
  }
}

// å®Ÿè¡Œç”»é¢ã«è¦ç´ ã‚’å¾©å…ƒã™ã‚‹é–¢æ•°
window.restoreSystemElementsToPreview = function restoreSystemElementsToPreview(elementsData, targetArea) {
  if (!targetArea) return;
  
  elementsData.forEach(elem => {
    try {
      let element = null;
      
      switch(elem.element_type) {
        case 'text_input':
          element = createPreviewTextInput(elem, false);
          break;
        case 'number_input':
          element = createPreviewTextInput(elem, true);
          break;
        case 'datetime_input':
          element = createPreviewDatetimeInput(elem);
          break;
        case 'checkbox_group':
          element = createPreviewCheckboxGroup(elem);
          break;
        case 'radio_group':
          element = createPreviewRadioGroup(elem);
          break;
        case 'button':
          element = createPreviewButton(elem);
          break;
        case 'text_box':
          element = createPreviewTextBox(elem);
          break;
        case 'roulette':
          element = createPreviewRoulette(elem);
          break;
        case 'timer':
          element = createPreviewTimer(elem);
          break;
      }
      
      if (element) {
        targetArea.appendChild(element);
      }
    } catch (error) {
      console.error('è¦ç´ ã®å¾©å…ƒã«å¤±æ•—:', elem, error);
    }
  });
}

// ä»¥ä¸‹ã€å®Ÿè¡Œç”»é¢ç”¨ã®è¦ç´ ä½œæˆé–¢æ•°
function createPreviewTextInput(elem, onlyNumber) {
  const container = document.createElement("div");
  container.classList.add("input-container");

  const label = document.createElement("div");
  label.classList.add("input-label");
  label.textContent = elem.element_label || (onlyNumber ? "æ•°å­—ï¼š" : "æ–‡å­—ï¼š");

  const placeholder = elem.element_config?.placeholder || (onlyNumber ? "æ•°å­—ã‚’å…¥åŠ›" : "æ–‡å­—ã‚’å…¥åŠ›ï¼ˆæ”¹è¡Œå¯ï¼‰");
  const actualValue = elem.element_value || "";

  if (onlyNumber) {
    const input = document.createElement("input");
    input.type = "text";
    input.inputMode = "numeric";
    input.pattern = "\\d*";
    input.classList.add("input-box");
    input.placeholder = placeholder;
    input.value = actualValue;
    input.setAttribute('data-only-number', 'true');
    container.appendChild(label);
    container.appendChild(input);
    attachNumberFilter(input);
  } else {
    const textarea = document.createElement("textarea");
    textarea.classList.add("input-box");
    textarea.placeholder = placeholder;
    textarea.value = actualValue;
    container.appendChild(label);
    container.appendChild(textarea);
  }

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewDatetimeInput(elem) {
  const container = document.createElement("div");
  container.classList.add("input-container");

  const label = document.createElement("div");
  label.classList.add("input-label");
  label.textContent = elem.element_label || "æ—¥æ™‚ï¼š";

  const input = document.createElement("input");
  input.type = "datetime-local";
  input.style.minWidth = "180px";
  input.style.minHeight = "36px";
  input.style.fontSize = "16px";
  input.style.padding = "4px 8px";
  input.style.boxSizing = "border-box";
  input.classList.add("input-box");
  input.value = elem.element_value || "";

  container.appendChild(label);
  container.appendChild(input);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewCheckboxGroup(elem) {
  const group = document.createElement('div');
  group.className = 'checkbox-group';
  
  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
  if (elem.element_label) {
    const groupLabel = document.createElement('div');
    groupLabel.className = 'group-label';
    groupLabel.textContent = elem.element_label;
    group.appendChild(groupLabel);
  }

  const options = elem.element_config?.options || [];
  options.forEach((optText, i) => {
    const row = document.createElement('div');
    row.className = 'checkbox-row';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.tabIndex = 0;

    const lbl = document.createElement('div');
    lbl.className = 'checkbox-label';
    lbl.textContent = optText;

    row.appendChild(cb);
    row.appendChild(lbl);
    group.appendChild(row);
  });

  group.style.left = elem.position_x + "px";
  group.style.top = elem.position_y + "px";
  if (elem.width) group.style.width = elem.width + "px";
  if (elem.height) group.style.height = elem.height + "px";

  return group;
}

function createPreviewRadioGroup(elem) {
  const group = document.createElement('div');
  group.className = 'radio-group';
  
  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
  if (elem.element_label) {
    const groupLabel = document.createElement('div');
    groupLabel.className = 'group-label';
    groupLabel.textContent = elem.element_label;
    group.appendChild(groupLabel);
  }

  const uniqueName = 'radio_group_' + Date.now() + '_' + Math.floor(Math.random()*1000);
  const options = elem.element_config?.options || [];
  
  options.forEach((optText, i) => {
    const row = document.createElement('div');
    row.className = 'radio-row';

    const rb = document.createElement('input');
    rb.type = 'radio';
    rb.name = uniqueName;
    rb.tabIndex = 0;

    const lbl = document.createElement('div');
    lbl.className = 'radio-label';
    lbl.textContent = optText;

    row.appendChild(rb);
    row.appendChild(lbl);
    group.appendChild(row);
  });

  group.style.left = elem.position_x + "px";
  group.style.top = elem.position_y + "px";
  if (elem.width) group.style.width = elem.width + "px";
  if (elem.height) group.style.height = elem.height + "px";

  return group;
}

function createPreviewButton(elem) {
  const btn = document.createElement("button");
  btn.classList.add("draggable-btn");
  btn.textContent = elem.element_label || "ãƒœã‚¿ãƒ³";

  const styleData = elem.style_data || {};
  if (elem.width) btn.style.width = elem.width + "px";
  if (elem.height) btn.style.height = elem.height + "px";
  if (styleData.background) btn.style.background = styleData.background;
  if (styleData.color) btn.style.color = styleData.color;

  btn.style.left = elem.position_x + "px";
  btn.style.top = elem.position_y + "px";

  const algorithmId = elem.element_config?.algorithm_id;
  const algorithmXml = elem.element_config?.algorithm_xml;
  const targetSystemId = elem.element_config?.target_system_id;
  
  if (algorithmId) btn.setAttribute('data-algorithm-id', algorithmId);
  if (algorithmXml) btn.setAttribute('data-algorithm-xml', algorithmXml);
  if (targetSystemId) btn.setAttribute('data-target-system', targetSystemId);
  
  btn.addEventListener('click', function(e) {
    e.stopPropagation();
    
    console.log('ğŸ”˜ ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯:', {
      text: btn.textContent,
      algorithmId: algorithmId,
      algorithmXml: algorithmXml ? `${algorithmXml.length}æ–‡å­—` : 'ãªã—',
      targetSystemId: targetSystemId
    });
    
    if (algorithmId && algorithmXml) {
      console.log('âœ… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œ:', algorithmId);
      executeAlgorithmFromButton(algorithmXml, btn.textContent);
    } else if (targetSystemId) {
      console.log('âœ… ã‚·ã‚¹ãƒ†ãƒ é·ç§»:', targetSystemId);
      loadSystemInPreview(targetSystemId);
    } else {
      console.warn('âš ï¸ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã‚‚è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }
  });

  return btn;
}

function createPreviewTextBox(elem) {
  const container = document.createElement("div");
  container.classList.add("text-input-container");

  const textDiv = document.createElement("div");
  textDiv.classList.add("text-input");
  textDiv.textContent = elem.element_value || "";

  container.appendChild(textDiv);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewRoulette(elem) {
  const container = document.createElement("div");
  container.classList.add("roulette-container");
  
  const config = elem.element_config || {};
  const items = config.items || ['é …ç›®1', 'é …ç›®2', 'é …ç›®3'];
  
  container.setAttribute('data-roulette-items', JSON.stringify(items));
  container.setAttribute('data-roulette-spinning', 'false');
  
  const wheel = document.createElement("div");
  wheel.classList.add("roulette-wheel");
  wheel.style.position = "relative";
  wheel.style.width = "200px";
  wheel.style.height = "200px";
  wheel.style.transition = "transform 3s cubic-bezier(0.25, 0.1, 0.25, 1)";
  wheel.dataset.currentRotation = "0";
  
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", "200");
  svg.setAttribute("height", "200");
  svg.setAttribute("viewBox", "0 0 200 200");
  
  const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B500', '#52C41A'];
  const centerX = 100;
  const centerY = 100;
  const radius = 95;
  const anglePerSegment = (2 * Math.PI) / items.length;
  
  items.forEach((item, index) => {
    const startAngle = index * anglePerSegment - Math.PI / 2;
    const endAngle = (index + 1) * anglePerSegment - Math.PI / 2;
    
    const x1 = centerX + radius * Math.cos(startAngle);
    const y1 = centerY + radius * Math.sin(startAngle);
    const x2 = centerX + radius * Math.cos(endAngle);
    const y2 = centerY + radius * Math.sin(endAngle);
    
    const largeArcFlag = anglePerSegment > Math.PI ? 1 : 0;
    
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`);
    path.setAttribute("fill", colors[index % colors.length]);
    path.setAttribute("stroke", "#fff");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);
    
    const textAngle = startAngle + anglePerSegment / 2;
    const textRadius = radius * 0.65;
    const textX = centerX + textRadius * Math.cos(textAngle);
    const textY = centerY + textRadius * Math.sin(textAngle);
    
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", textX);
    text.setAttribute("y", textY);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("fill", "#fff");
    text.setAttribute("font-size", "14");
    text.setAttribute("font-weight", "bold");
    text.setAttribute("transform", `rotate(${(textAngle * 180 / Math.PI) + 90}, ${textX}, ${textY})`);
    text.style.textShadow = "1px 1px 2px rgba(0,0,0,0.8)";
    text.textContent = item;
    svg.appendChild(text);
  });
  
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", centerX);
  circle.setAttribute("cy", centerY);
  circle.setAttribute("r", radius);
  circle.setAttribute("fill", "none");
  circle.setAttribute("stroke", "#333");
  circle.setAttribute("stroke-width", "4");
  svg.appendChild(circle);
  
  wheel.appendChild(svg);
  
  const pin = document.createElement("div");
  pin.style.position = "absolute";
  pin.style.top = "-15px";
  pin.style.left = "46%";
  pin.style.transform = "translateX(-50%)";
  pin.style.width = "0";
  pin.style.height = "0";
  pin.style.borderLeft = "10px solid transparent";
  pin.style.borderRight = "10px solid transparent";
  pin.style.borderTop = "20px solid #FF0000";
  pin.style.zIndex = "10";
  pin.style.pointerEvents = "none";
  
  const result = document.createElement("div");
  result.classList.add("roulette-result");
  result.style.marginTop = "10px";
  result.style.padding = "8px";
  result.style.background = "#f0f0f0";
  result.style.borderRadius = "4px";
  result.style.textAlign = "center";
  result.style.fontWeight = "bold";
  result.textContent = "çµæœ: -";
  
  const spinBtn = document.createElement("button");
  spinBtn.classList.add("roulette-btn", "spin");
  spinBtn.textContent = "ã‚¹ãƒ”ãƒ³";
  spinBtn.style.marginTop = "10px";
  spinBtn.style.padding = "8px 20px";
  spinBtn.style.fontSize = "16px";
  spinBtn.style.cursor = "pointer";
  spinBtn.style.position = "relative";
  spinBtn.style.zIndex = "100";
  spinBtn.onclick = function(e) {
    e.stopPropagation();
    const spinning = container.getAttribute('data-roulette-spinning') === 'true';
    if (spinning) return;
    
    container.setAttribute('data-roulette-spinning', 'true');
    spinBtn.disabled = true;
    spinBtn.style.cursor = 'not-allowed';
    spinBtn.style.opacity = '0.6';
    
    const currentRotation = parseFloat(wheel.dataset.currentRotation) || 0;
    const spins = 5 + Math.random() * 3;
    const extraDegrees = Math.random() * 360;
    const newRotation = currentRotation + spins * 360 + extraDegrees;
    
    wheel.style.transform = `rotate(${newRotation}deg)`;
    wheel.dataset.currentRotation = newRotation;
    
    setTimeout(() => {
      const finalAngle = ((newRotation % 360) + 360) % 360;
      const segmentAngle = 360 / items.length;
      const angleOnWheel = (270 - finalAngle + 360) % 360;
      const selectedIndex = Math.floor((angleOnWheel + 90) / segmentAngle) % items.length;
      
      result.textContent = `çµæœ: ${items[selectedIndex]}`;
      container.setAttribute('data-roulette-spinning', 'false');
      spinBtn.disabled = false;
      spinBtn.style.cursor = 'pointer';
      spinBtn.style.opacity = '1';
    }, 3000);
  };
  
  const wheelWrapper = document.createElement("div");
  wheelWrapper.style.position = "relative";
  wheelWrapper.style.pointerEvents = "none";
  wheelWrapper.appendChild(pin);
  wheelWrapper.appendChild(wheel);
  
  container.appendChild(wheelWrapper);
  container.appendChild(result);
  container.appendChild(spinBtn);
  
  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewTimer(elem) {
  const container = document.createElement('div');
  container.className = 'timer-container';
  
  const config = elem.element_config || {};
  const mode = config.mode || 'countup';
  const initialTime = config.initial_time || 0;
  
  container.setAttribute('data-timer-mode', mode);
  container.setAttribute('data-timer-running', 'false');
  container.setAttribute('data-timer-value', initialTime.toString());
  container.setAttribute('data-initial-time', initialTime.toString());

  const display = document.createElement('div');
  display.className = 'timer-display';
  display.textContent = formatTimerDisplay(initialTime);

  const btnContainer = document.createElement('div');
  btnContainer.className = 'timer-buttons';

  const startBtn = document.createElement('button');
  startBtn.className = 'timer-btn start';
  startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';

  const resetBtn = document.createElement('button');
  resetBtn.className = 'timer-btn reset';
  resetBtn.textContent = 'ãƒªã‚»ãƒƒãƒˆ';

  btnContainer.appendChild(startBtn);
  btnContainer.appendChild(resetBtn);

  container.appendChild(display);
  container.appendChild(btnContainer);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  setupTimerEvents(container, startBtn, resetBtn, display, mode, initialTime);

  return container;
}

function setupTimerEvents(container, startBtn, resetBtn, display, mode, initialTime) {
  let intervalId = null;

  startBtn.onclick = function(e) {
    e.stopPropagation();
    const running = container.getAttribute('data-timer-running') === 'true';
    
    if (running) {
      if (intervalId) clearInterval(intervalId);
      container.setAttribute('data-timer-running', 'false');
      startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
    } else {
      container.setAttribute('data-timer-running', 'true');
      startBtn.textContent = 'ã‚¹ãƒˆãƒƒãƒ—';
      
      intervalId = setInterval(() => {
        let currentValue = parseInt(container.getAttribute('data-timer-value')) || 0;
        
        if (mode === 'countdown') {
          currentValue = Math.max(0, currentValue - 1);
          container.setAttribute('data-timer-value', currentValue.toString());
          display.textContent = formatTimerDisplay(currentValue);
          
          if (currentValue === 0) {
            if (intervalId) clearInterval(intervalId);
            container.setAttribute('data-timer-running', 'false');
            startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
          }
        } else {
          currentValue += 1;
          container.setAttribute('data-timer-value', currentValue.toString());
          display.textContent = formatTimerDisplay(currentValue);
        }
      }, 1000);
    }
  };

  resetBtn.onclick = function(e) {
    e.stopPropagation();
    if (intervalId) clearInterval(intervalId);
    container.setAttribute('data-timer-running', 'false');
    container.setAttribute('data-timer-value', initialTime.toString());
    display.textContent = formatTimerDisplay(initialTime);
    startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
  };
}

function formatTimerDisplay(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return String(h).padStart(2, '0') + ':' + 
         String(m).padStart(2, '0') + ':' + 
         String(s).padStart(2, '0');
}

// ç¾åœ¨ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¨ãƒªã‚¢ã®è¦ç´ ã‚’åé›†ã™ã‚‹é–¢æ•°
window.collectCurrentElements = function collectCurrentElements() {
  console.log('ğŸ” collectCurrentElements() é–‹å§‹');
  const slide = document.getElementById('slideArea');
  if (!slide) {
    console.warn('âš ï¸ slideAreaãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    return [];
  }
  
  console.log('ğŸ“‹ slideAreaå†…ã®è¦ç´ ã‚’åé›†ä¸­...');
  const elements = [];
  
  // ãƒ†ã‚­ã‚¹ãƒˆ/æ•°å€¤/æ—¥æ™‚å…¥åŠ›
  slide.querySelectorAll('.input-container').forEach(container => {
    const label = container.querySelector('.input-label');
    const input = container.querySelector('.input-box');
    const labelText = label ? label.textContent.trim() : '';
    const inputValue = input ? input.value.trim() : '';
    const placeholder = input ? input.placeholder : '';
    const onlyNumber = input && input.getAttribute('data-only-number') === 'true';
    const isDatetime = input && input.type === 'datetime-local';
    
    let elementType = 'text_input';
    if (onlyNumber) elementType = 'number_input';
    if (isDatetime) elementType = 'datetime_input';
    
    elements.push({
      element_type: elementType,
      element_label: labelText,
      element_value: inputValue,
      position_x: parseInt(container.style.left) || 0,
      position_y: parseInt(container.style.top) || 0,
      width: container.offsetWidth || null,
      height: container.offsetHeight || null,
      style_data: {},
      element_config: {
        placeholder: placeholder
      }
    });
  });
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—
  slide.querySelectorAll('.checkbox-group').forEach(group => {
    const groupLabelDiv = group.querySelector('.checkbox-group-label');
    const groupLabel = groupLabelDiv ? groupLabelDiv.textContent.trim() : '';
    
    const rows = group.querySelectorAll('.checkbox-row');
    const options = [];
    rows.forEach(row => {
      const label = row.querySelector('.checkbox-label');
      if (label) options.push(label.textContent.trim());
    });
    
    elements.push({
      element_type: 'checkbox_group',
      element_label: groupLabel,
      element_value: '',
      position_x: parseInt(group.style.left) || 0,
      position_y: parseInt(group.style.top) || 0,
      width: group.offsetWidth || null,
      height: group.offsetHeight || null,
      style_data: {},
      element_config: { options: options }
    });
  });
  
  // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
  slide.querySelectorAll('.radio-group').forEach(group => {
    const groupLabelDiv = group.querySelector('.radio-group-label');
    const groupLabel = groupLabelDiv ? groupLabelDiv.textContent.trim() : '';
    
    const rows = group.querySelectorAll('.radio-row');
    const options = [];
    rows.forEach(row => {
      const label = row.querySelector('.radio-label');
      if (label) options.push(label.textContent.trim());
    });
    
    elements.push({
      element_type: 'radio_group',
      element_label: groupLabel,
      element_value: '',
      position_x: parseInt(group.style.left) || 0,
      position_y: parseInt(group.style.top) || 0,
      width: group.offsetWidth || null,
      height: group.offsetHeight || null,
      style_data: {},
      element_config: { options: options }
    });
  });
  
  // ãƒœã‚¿ãƒ³
  slide.querySelectorAll('.draggable-btn').forEach(btn => {
    const targetSystemId = btn.getAttribute('data-target-system');
    const algorithmId = btn.getAttribute('data-algorithm-id');
    const algorithmXml = btn.getAttribute('data-algorithm-xml');
    const buttonId = btn.getAttribute('data-button-id');
    let buttonText = btn.textContent.trim();
    buttonText = buttonText.replace(/â‰¡/g, '').trim();
    
    elements.push({
      element_type: 'button',
      element_label: buttonText,
      element_value: '',
      position_x: parseInt(btn.style.left) || 0,
      position_y: parseInt(btn.style.top) || 0,
      width: parseInt(btn.style.width) || null,
      height: parseInt(btn.style.height) || null,
      style_data: {
        background: btn.style.background || btn.style.backgroundColor,
        color: btn.style.color
      },
      element_config: {
        button_id: buttonId,
        target_system_id: targetSystemId,
        algorithm_id: algorithmId,
        algorithm_xml: algorithmXml
      }
    });
  });
  
  // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹
  slide.querySelectorAll('.text-box-container').forEach(container => {
    const textInput = container.querySelector('.text-box');
    const content = textInput ? (textInput.value || textInput.textContent || '').trim() : '';
    
    console.log('ğŸ“¦ ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’åé›†:', { content, position: container.style.left + ',' + container.style.top });
    
    elements.push({
      element_type: 'text_box',
      element_label: '',
      element_value: content,
      position_x: parseInt(container.style.left) || 0,
      position_y: parseInt(container.style.top) || 0,
      width: parseInt(container.style.width) || null,
      height: parseInt(container.style.height) || null,
      style_data: {},
      element_config: {}
    });
  });
  
  // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ
  slide.querySelectorAll('.roulette-container').forEach(roulette => {
    const items = JSON.parse(roulette.getAttribute('data-roulette-items') || '[]');
    
    elements.push({
      element_type: 'roulette',
      element_label: '',
      element_value: '',
      position_x: parseInt(roulette.style.left) || 0,
      position_y: parseInt(roulette.style.top) || 0,
      width: parseInt(roulette.style.width) || null,
      height: parseInt(roulette.style.height) || null,
      style_data: {},
      element_config: {
        items: items
      }
    });
  });
  
  // ã‚¿ã‚¤ãƒãƒ¼
  slide.querySelectorAll('.timer-container').forEach(timer => {
    const mode = timer.getAttribute('data-timer-mode') || 'countup';
    const initialTime = parseInt(timer.getAttribute('data-initial-time')) || 0;
    
    elements.push({
      element_type: 'timer',
      element_label: '',
      element_value: '',
      position_x: parseInt(timer.style.left) || 0,
      position_y: parseInt(timer.style.top) || 0,
      width: parseInt(timer.style.width) || null,
      height: parseInt(timer.style.height) || null,
      style_data: {},
      element_config: {
        mode: mode,
        initial_time: initialTime
      }
    });
  });
  
  // å›³å½¢
  slide.querySelectorAll('.shape-element').forEach(shape => {
    const shapeType = shape.getAttribute('data-shape-type') || 'rectangle';
    const shapeColor = shape.getAttribute('data-shape-color') || '#333333';
    const shapeFill = shape.getAttribute('data-shape-fill') || 'transparent';
    
    let width, height;
    if (shapeType === 'triangle') {
      const borderBottom = shape.style.borderBottomWidth || shape.style.borderBottom;
      height = parseInt(borderBottom) || 87;
      width = Math.floor(height * 100 / 87);
    } else {
      width = parseInt(shape.style.width) || 100;
      height = parseInt(shape.style.height) || 100;
    }
    
    console.log('ğŸ“¦ å›³å½¢ã‚’åé›†:', { type: shapeType, color: shapeColor, fill: shapeFill, position: shape.style.left + ',' + shape.style.top });
    
    elements.push({
      element_type: 'shape',
      element_label: '',
      element_value: '',
      position_x: parseInt(shape.style.left) || 0,
      position_y: parseInt(shape.style.top) || 0,
      width: width,
      height: height,
      style_data: {},
      element_config: {
        shape_type: shapeType,
        color: shapeColor,
        fill_color: shapeFill
      }
    });
  });
  
  // ç”»åƒ
  slide.querySelectorAll('.image-element').forEach(imageContainer => {
    const imageSrc = imageContainer.getAttribute('data-image-src') || '';
    const img = imageContainer.querySelector('img');
    
    console.log('ğŸ“¦ ç”»åƒã‚’åé›†:', { src: imageSrc.substring(0, 50) + '...', position: imageContainer.style.left + ',' + imageContainer.style.top });
    
    elements.push({
      element_type: 'image',
      element_label: '',
      element_value: imageSrc,
      position_x: parseInt(imageContainer.style.left) || 0,
      position_y: parseInt(imageContainer.style.top) || 0,
      width: parseInt(imageContainer.style.width) || (img ? img.width : 100),
      height: parseInt(imageContainer.style.height) || (img ? img.height : 100),
      style_data: {},
      element_config: {}
    });
  });
  
  console.log(`âœ… åé›†å®Œäº†: ${elements.length}å€‹ã®è¦ç´ `);
  console.log('ğŸ“Š è¦ç´ ã®å†…è¨³:', elements.map(e => e.element_type));
  return elements;
}

// ========================================
// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–¢æ•°
// ========================================
window.executeAlgorithmFromButton = async function executeAlgorithmFromButton(blocklyXml, buttonName) {
  console.log('ğŸ¯ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–‹å§‹:', buttonName);
  
  if (!blocklyXml) {
    alert('ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    return;
  }

  // BlocklyãŒã¾ã ãƒ­ãƒ¼ãƒ‰ä¸­ã®å ´åˆã¯ã€loadBlockly()ã‚’å¾…æ©Ÿ
  if (typeof Blockly === 'undefined') {
    console.log('â³ Blocklyã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...');
    try {
      await loadBlockly();
      console.log('âœ… Blockly loaded successfully');
    } catch (error) {
      console.error('âŒ Blockly loading failed:', error);
      const retry = await customConfirm('Blocklyã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚\n\nãƒªãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ', {
        title: 'èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼',
        confirmText: 'ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹',
        cancelText: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«'
      });
      if (retry) {
        location.reload();
      }
      return;
    }
  }
  
  console.log('âœ… Blockly ready, executing algorithm');

  // âš¡ é‡è¦: XMLã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å¾©å…ƒã™ã‚‹å‰ã«systemsListã‚’è¨­å®š
  const currentSystemId = {{ system.system_id|default:"null" }};
  const otherSystems = {{ other_systems_json|safe }};
  window._systemsList = otherSystems || [];
  if (currentSystemId) {
    window._systemsList.unshift({
      system_id: currentSystemId,
      system_name: 'ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ '
    });
  }
  console.log('âœ… window._systemsListè¨­å®šå®Œäº†:', window._systemsList.length, 'ä»¶');

  try {
    // éè¡¨ç¤ºã®Blocklyãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½œæˆ
    const tempDiv = document.createElement('div');
    tempDiv.style.display = 'none';
    document.body.appendChild(tempDiv);

    const workspace = Blockly.inject(tempDiv, {
      toolbox: '<xml></xml>'
    });

    // ã‚«ã‚¹ã‚¿ãƒ ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®šç¾©
    if (!Blockly.Blocks['load_system']) {
      Blockly.Blocks['load_system'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚ˆã¿ã“ã‚€:")
            .appendField(new Blockly.FieldTextInput("0"), "SYSTEM_ID");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
        }
      };
    }

    // ã‚·ã‚¹ãƒ†ãƒ æ¡ä»¶ãƒ–ãƒ­ãƒƒã‚¯ç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    window.systemConditionHelpers = {
      systemsCache: null,
      
      // åˆ©ç”¨å¯èƒ½ãªã‚·ã‚¹ãƒ†ãƒ ä¸€è¦§ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰
      async getSystemList() {
        if (this.systemsCache) {
          return this.systemsCache;
        }
        
        const currentSystemId = {{ system.system_id|default:"null" }};
        const otherSystems = {{ other_systems_json|safe }};
        
        const systems = [
          ['ã›ã‚“ãŸãã—ã¦ã­', '0']
        ];
        
        if (currentSystemId) {
          systems.push(['ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ', String(currentSystemId)]);
        }
        
        if (otherSystems && Array.isArray(otherSystems)) {
          otherSystems.forEach(sys => {
            systems.push([sys.system_name, String(sys.system_id)]);
          });
        }
        
        this.systemsCache = systems;
        
        // Blocklyå®Ÿè¡Œç”¨ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«è¨­å®š
        window._systemsList = otherSystems || [];
        if (currentSystemId) {
          window._systemsList.unshift({
            system_id: currentSystemId,
            system_name: 'ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ '
          });
        }
        
        return systems;
      },
      
      // æŒ‡å®šã‚·ã‚¹ãƒ†ãƒ ã®ãƒ©ãƒ™ãƒ«ä¸€è¦§ã‚’å–å¾—
      async getSystemLabels(systemId) {
        if (!systemId || systemId === '0') {
          return [['ã›ã‚“ãŸãã—ã¦ã­', '']];
        }
        
        try {
          const response = await fetch(`/accounts/system/api/system-elements/${systemId}/`);
          if (!response.ok) throw new Error('Failed to fetch labels');
          
          const data = await response.json();
          const labels = [['ã›ã‚“ãŸãã—ã¦ã­', '']];
          
          if (data.elements && Array.isArray(data.elements)) {
            data.elements.forEach(elem => {
              if (elem.element_label) {
                labels.push([elem.element_label, JSON.stringify({
                  label: elem.element_label,
                  type: elem.element_type,
                  config: elem.element_config
                })]);
              }
            });
          }
          
          return labels;
        } catch (error) {
          console.error('ãƒ©ãƒ™ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
          return [['ã‚¨ãƒ©ãƒ¼', '']];
        }
      },
      
      // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹/ãƒ©ã‚¸ã‚ªã®é …ç›®ä¸€è¦§ã‚’å–å¾—
      getCheckboxItems(labelData) {
        try {
          const data = JSON.parse(labelData);
          if (data.config && data.config.options && Array.isArray(data.config.options)) {
            const items = [['ã›ã‚“ãŸãã—ã¦ã­', '']];
            data.config.options.forEach(opt => {
              items.push([opt, opt]);
            });
            return items;
          }
        } catch (e) {
          console.error('é …ç›®å–å¾—ã‚¨ãƒ©ãƒ¼:', e);
        }
        return [['é …ç›®ãªã—', '']];
      }
    };

    // system_conditionãƒ–ãƒ­ãƒƒã‚¯ï¼ˆmutationæ©Ÿèƒ½ä»˜ãï¼‰
    if (!Blockly.Blocks['system_condition']) {
      Blockly.Blocks['system_condition'] = {
        init: function() {
          const block = this;
          
          // SYSTEM_IDãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³: menuGenerator_ã‚’é–¢æ•°ã§è¨­å®šã—ã€å¸¸ã«æœ€æ–°ã®window._systemsListã‚’å‚ç…§
          const systemDropdown = new Blockly.FieldDropdown(function() {
            const systems = window._systemsList || [];
            if (systems.length > 0) {
              return [['ã›ã‚“ãŸãã—ã¦ã­', '0'], ...systems.map(sys => [sys.system_name, sys.system_id.toString()])];
            }
            return [['ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“', '0']];
          });
          
          this.appendDummyInput('SYSTEM_INPUT')
            .appendField("ã‚‚ã— ã‚·ã‚¹ãƒ†ãƒ ")
            .appendField(systemDropdown, "SYSTEM_ID")
            .appendField("ã®");
          
          // ELEMENT_NAMEãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³: ä»»æ„ã®å€¤ã‚’è¨±å¯ã™ã‚‹validatorè¨­å®š
          const labelDropdown = new Blockly.FieldDropdown([['ã›ã‚“ãŸãã—ã¦ã­', '']]);
          labelDropdown.setValidator(function(newValue) {
            // ä»»æ„ã®å€¤ã‚’è¨±å¯ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’é˜²ãï¼‰
            return newValue;
          });
          
          this.appendDummyInput('LABEL_INPUT')
            .appendField("ãƒ©ãƒ™ãƒ«ï¼š")
            .appendField(labelDropdown, "ELEMENT_NAME");
          
          this.appendDummyInput('CONDITION_INPUT')
            .appendField("ãŒ")
            .appendField(new Blockly.FieldDropdown([
              ["=","EQ"],
              ["â‰ ","NEQ"],
              [">","GT"],
              ["<","LT"],
              ["â‰¥","GTE"],
              ["â‰¤","LTE"],
              ["ãµãã‚€","CONTAINS"],
              ["ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹","CHECKED"]
            ]), "OP")
            .appendField(new Blockly.FieldTextInput("ã‚ãŸã„"), "VALUE")
            .appendField("ãªã‚‰");
          
          this.appendStatementInput("DO")
            .appendField("ã™ã‚‹ã“ã¨");
          this.appendStatementInput("ELSE")
            .appendField("ãã†ã§ãªã‘ã‚Œã°");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
          
          this.itemCount = 0;
          this.isCheckboxMode = false;
        },
        
        // mutationæ©Ÿèƒ½: ä¿å­˜
        mutationToDom: function() {
          const container = document.createElement('mutation');
          container.setAttribute('item_count', this.itemCount || 0);
          container.setAttribute('is_checkbox', this.isCheckboxMode || false);
          if (this.currentItems) {
            container.setAttribute('items_json', JSON.stringify(this.currentItems));
          }
          // SYSTEM_IDã¨ELEMENT_NAMEã‚‚ä¿å­˜
          const systemIdField = this.getField('SYSTEM_ID');
          const elementNameField = this.getField('ELEMENT_NAME');
          if (systemIdField) {
            container.setAttribute('system_id_value', systemIdField.getValue());
          }
          if (elementNameField) {
            container.setAttribute('element_name_value', elementNameField.getValue());
          }
          for (let i = 0; i < (this.itemCount || 0); i++) {
            const field = this.getField('ITEM_' + i);
            if (field) {
              container.setAttribute('item_' + i + '_value', field.getValue());
            }
          }
          return container;
        },
        
        // mutationæ©Ÿèƒ½: å¾©å…ƒ
        domToMutation: function(xmlElement) {
          const itemCount = parseInt(xmlElement.getAttribute('item_count')) || 0;
          const isCheckbox = xmlElement.getAttribute('is_checkbox') === 'true';
          const itemsJson = xmlElement.getAttribute('items_json');
          const systemIdValue = xmlElement.getAttribute('system_id_value');
          const elementNameValue = xmlElement.getAttribute('element_name_value');
          
          // SYSTEM_IDã¨ELEMENT_NAMEã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã‚’æ›´æ–°
          const systems = window._systemsList || [];
          if (systems.length > 0) {
            const systemOptions = [['ã›ã‚“ãŸãã—ã¦ã­', '0'], ...systems.map(sys => [sys.system_name, sys.system_id.toString()])];
            const systemField = this.getField('SYSTEM_ID');
            if (systemField) {
              systemField.menuGenerator_ = systemOptions;
              // ä¿å­˜ã•ã‚ŒãŸå€¤ã‚’å¾©å…ƒ
              if (systemIdValue) {
                setTimeout(() => {
                  systemField.setValue(systemIdValue);
                }, 50);
              }
            }
          }
          
          // ELEMENT_NAMEãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’å¾©å…ƒ
          if (elementNameValue) {
            const elementNameField = this.getField('ELEMENT_NAME');
            if (elementNameField) {
              // é¸æŠè‚¢ã‚’è¨­å®šï¼ˆç¾åœ¨ã¯ç©ºã§ã‚‚OKã€XMLã®å€¤ãŒã‚ã‚Œã°å—ã‘å…¥ã‚Œã‚‹ï¼‰
              elementNameField.menuGenerator_ = [[elementNameValue, elementNameValue], ['ã›ã‚“ãŸãã—ã¦ã­', '']];
              setTimeout(() => {
                elementNameField.setValue(elementNameValue);
              }, 50);
            }
          }
          
          if (isCheckbox && itemCount > 0) {
            this.isCheckboxMode = true;
            this.currentItems = itemsJson ? JSON.parse(itemsJson) : [['ã›ã‚“ãŸãã—ã¦ã­', '']];
            
            if (this.getInput('CONDITION_INPUT')) {
              this.removeInput('CONDITION_INPUT');
            }
            
            const doConnection = this.getInput('DO') ? this.getInput('DO').connection.targetConnection : null;
            const elseConnection = this.getInput('ELSE') ? this.getInput('ELSE').connection.targetConnection : null;
            if (this.getInput('DO')) this.removeInput('DO');
            if (this.getInput('ELSE')) this.removeInput('ELSE');
            
            this.appendDummyInput('ITEM_INPUT_0')
              .appendField("ã®ã€€é …ç›®ï¼š")
              .appendField(new Blockly.FieldDropdown(this.currentItems), "ITEM_0");
            
            for (let i = 1; i < itemCount; i++) {
              this.appendDummyInput('ITEM_INPUT_' + i)
                .appendField("ã€€ã€€ã€€ã€€ã€€")
                .appendField(new Blockly.FieldDropdown(this.currentItems), "ITEM_" + i);
            }
            
            this.appendDummyInput('BUTTONS_INPUT');
            
            this.appendDummyInput('LOGIC_INPUT')
              .appendField(new Blockly.FieldDropdown([
                ["ã®ã¿","AND"],
                ["ãµãã‚ã‚‹","OR"]
              ]), "LOGIC")
              .appendField("ãŒ");
            
            this.appendDummyInput('CHECK_STATUS_INPUT')
              .appendField(new Blockly.FieldDropdown([
                ["ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹","CHECKED"],
                ["ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„","UNCHECKED"]
              ]), "CHECK_STATUS")
              .appendField("ãªã‚‰");
            
            this.itemCount = itemCount;
            
            this.appendStatementInput("DO")
              .appendField("ã™ã‚‹ã“ã¨");
            this.appendStatementInput("ELSE")
              .appendField("ãã†ã§ãªã‘ã‚Œã°");
            
            if (doConnection) {
              this.getInput('DO').connection.connect(doConnection);
            }
            if (elseConnection) {
              this.getInput('ELSE').connection.connect(elseConnection);
            }
            
            // ELEMENT_NAMEã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³é¸æŠè‚¢ã‚‚æ›´æ–°
            const elementNameField = this.getField('ELEMENT_NAME');
            if (elementNameField && this.currentItems) {
              // currentItemsã‹ã‚‰ãƒ©ãƒ™ãƒ«æƒ…å ±ã‚’å«ã‚€é¸æŠè‚¢ã‚’ä½œæˆ
              // æ³¨: currentItemsã¯é …ç›®ä¸€è¦§ãªã®ã§ã€ãƒ©ãƒ™ãƒ«é¸æŠè‚¢ã¯åˆ¥é€”å¿…è¦
              // ã“ã“ã§ã¯ã€XMLã‹ã‚‰ELEMENT_NAMEã®å€¤ãŒå¾©å…ƒã•ã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…
            }
            
            setTimeout(() => {
              for (let i = 0; i < itemCount; i++) {
                const savedValue = xmlElement.getAttribute('item_' + i + '_value');
                if (savedValue) {
                  const field = this.getField('ITEM_' + i);
                  if (field) {
                    field.setValue(savedValue);
                  }
                }
              }
            }, 100);
          }
        }
      };
    }
    
    if (!Blockly.Blocks['display_system']) {
      Blockly.Blocks['display_system'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ã‚·ã‚¹ãƒ†ãƒ ã‚’ã²ã‚‡ã†ã˜:")
            .appendField(new Blockly.FieldTextInput("0"), "SYSTEM_ID");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
        }
      };
    }

    if (!Blockly.Blocks['text_block']) {
      Blockly.Blocks['text_block'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ãƒ†ã‚­ã‚¹ãƒˆ:")
            .appendField(new Blockly.FieldTextInput("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"), "message");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(160);
        }
      };
    }

    // XMLã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’èª­ã¿è¾¼ã‚€
    const xml = Blockly.utils.xml.textToDom(blocklyXml);
    Blockly.Xml.domToWorkspace(xml, workspace);

    // ğŸ”§ XMLã‹ã‚‰ã®å¾©å…ƒã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£: system_conditionãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å€¤ã‚’å¾©å…ƒ
    const xmlDoc = Blockly.utils.xml.textToDom(blocklyXml);
    const systemConditionBlocks = xmlDoc.querySelectorAll('block[type="system_condition"]');
    systemConditionBlocks.forEach(blockXml => {
      const mutationTag = blockXml.querySelector('mutation');
      if (mutationTag) {
        const systemIdValue = mutationTag.getAttribute('system_id_value');
        const elementNameValue = mutationTag.getAttribute('element_name_value');
        
        if (systemIdValue || elementNameValue) {
          // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®å¯¾å¿œã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¦‹ã¤ã‘ã‚‹
          const blockId = blockXml.getAttribute('id');
          const block = workspace.getBlockById(blockId);
          
          if (block) {
            // SYSTEM_IDãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é¸æŠè‚¢ã‚’æ›´æ–°ã—ã¦å€¤ã‚’è¨­å®š
            if (systemIdValue) {
              const systemField = block.getField('SYSTEM_ID');
              if (systemField && window._systemsList) {
                const systemOptions = [['ã›ã‚“ãŸãã—ã¦ã­', '0'], ...window._systemsList.map(sys => [sys.system_name, sys.system_id.toString()])];
                systemField.menuGenerator_ = systemOptions;
                setTimeout(() => {
                  systemField.setValue(systemIdValue);
                  console.log('âœ… SYSTEM_IDå¾©å…ƒ:', systemIdValue);
                }, 10);
              }
            }
            
            // ELEMENT_NAMEãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é¸æŠè‚¢ã‚’æ›´æ–°ã—ã¦å€¤ã‚’è¨­å®š
            if (elementNameValue) {
              const elementField = block.getField('ELEMENT_NAME');
              if (elementField) {
                console.log('ğŸ”§ ELEMENT_NAMEå¾©å…ƒé–‹å§‹:', elementNameValue);
                elementField.menuGenerator_ = [[elementNameValue, elementNameValue], ['ã›ã‚“ãŸãã—ã¦ã­', '']];
                setTimeout(() => {
                  try {
                    elementField.setValue(elementNameValue);
                    console.log('âœ… ELEMENT_NAMEå¾©å…ƒå®Œäº†:', elementNameValue);
                  } catch (e) {
                    console.error('âŒ ELEMENT_NAMEå¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
                  }
                }, 100);
              }
            }
          }
        }
      }
    });

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç›´æ¥å‡¦ç†
    const blocks = workspace.getTopBlocks(true);
    
    // processBlocké–¢æ•°ã‚’å®šç¾©
    async function processBlock(block) {
      if (!block) return;
      
      switch(block.type) {
        case 'text_block':
          const msg = block.getFieldValue('message') || '';
          console.log('ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆ:', msg);
          break;
          
        case 'system_condition':
          const sysId = block.getFieldValue('SYSTEM_ID');
          const elementName = block.getFieldValue('ELEMENT_NAME');
          
          // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
          const isCheckboxMode = block.getField('LOGIC') !== null;
          
          console.log('ğŸ” system_conditionå®Ÿè¡Œé–‹å§‹:', {
            systemId: sysId,
            elementName: elementName,
            isCheckboxMode: isCheckboxMode
          });
          
          let conditionMet = false;
          
          if (isCheckboxMode) {
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹/ãƒ©ã‚¸ã‚ªãƒ¢ãƒ¼ãƒ‰
            const logic = block.getFieldValue('LOGIC'); // AND or OR
            const checkStatus = block.getFieldValue('CHECK_STATUS'); // CHECKED or UNCHECKED
            
            // é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—ï¼ˆITEM_0, ITEM_1, ITEM_2...ï¼‰
            const selectedItems = [];
            for (let i = 0; i < 10; i++) {
              const field = block.getField('ITEM_' + i);
              if (field) {
                const value = field.getValue();
                if (value && value !== '' && value !== 'ã›ã‚“ãŸãã—ã¦ã­') {
                  selectedItems.push(value);
                }
              }
            }
            
            console.log('ğŸ” ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹æ¡ä»¶:', {
              systemId: sysId,
              elementName: elementName,
              selectedItems: selectedItems,
              logic: logic,
              checkStatus: checkStatus
            });
            
            // å®Ÿè¡Œç”»é¢ã‹ã‚‰ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹é …ç›®ã‚’å–å¾—
            const previewArea = document.getElementById('previewSlideArea');
            if (previewArea) {
              const checkedItems = [];
              
              // ãƒ©ãƒ™ãƒ«åã‹ã‚‰elementNameã®JSONã‚’å–ã‚Šå‡ºã™
              let targetLabel = elementName;
              try {
                const parsed = JSON.parse(elementName);
                if (parsed.label) targetLabel = parsed.label;
                console.log('ğŸ“Œ æ¤œç´¢ã™ã‚‹ãƒ©ãƒ™ãƒ«å:', targetLabel);
              } catch (e) {
                console.log('ğŸ“Œ æ¤œç´¢ã™ã‚‹ãƒ©ãƒ™ãƒ«åï¼ˆJSONè§£æãªã—ï¼‰:', targetLabel);
              }
              
              // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™
              const checkboxGroups = previewArea.querySelectorAll('.checkbox-group');
              console.log('ğŸ“‹ è¦‹ã¤ã‹ã£ãŸãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—æ•°:', checkboxGroups.length);
              
              for (const group of checkboxGroups) {
                const groupLabel = group.querySelector('.checkbox-group-label');
                const groupLabelText = groupLabel ? groupLabel.textContent.trim() : '';
                console.log('  - ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«:', groupLabelText);
                
                if (groupLabelText === targetLabel) {
                  console.log('âœ… ä¸€è‡´ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç™ºè¦‹!');
                  const rows = group.querySelectorAll('.checkbox-row');
                  rows.forEach(row => {
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    const label = row.querySelector('.checkbox-label');
                    if (checkbox && label) {
                      const labelText = label.textContent.trim();
                      const isChecked = checkbox.checked;
                      console.log(`  ãƒ»é …ç›®ã€Œ${labelText}ã€: ${isChecked ? 'ãƒã‚§ãƒƒã‚¯âœ“' : 'ãƒã‚§ãƒƒã‚¯ãªã—â˜'}`);
                      if (isChecked) {
                        checkedItems.push(labelText);
                      }
                    }
                  });
                  break;
                }
              }
              
              console.log('ğŸ“ å®Ÿéš›ã«ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹é …ç›®:', checkedItems);
              console.log('ğŸ“ åˆ¤å®šã™ã‚‹é …ç›®:', selectedItems);
              
              // åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
              if (checkStatus === 'CHECKED') {
                if (logic === 'AND') {
                  // ã€Œã®ã¿ã€= å®Œå…¨ä¸€è‡´ï¼ˆé¸æŠã—ãŸé …ç›®ã ã‘ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ï¼‰
                  const selectedSet = new Set(selectedItems);
                  const checkedSet = new Set(checkedItems);
                  
                  const sameSize = selectedSet.size === checkedSet.size;
                  const allMatch = [...selectedSet].every(item => checkedSet.has(item));
                  
                  conditionMet = sameSize && allMatch;
                  
                  console.log(`âœ“ ã€Œã®ã¿ã€åˆ¤å®š: é …ç›®æ•°ä¸€è‡´=${sameSize}, å…¨é …ç›®ä¸€è‡´=${allMatch} â†’ ${conditionMet ? 'âœ…æ¡ä»¶æº€ãŸã™' : 'âŒæ¡ä»¶æº€ãŸã•ãªã„'}`);
                } else {
                  // ã€Œãµãã‚ã‚‹ã€= é¸æŠã—ãŸé …ç›®ãŒ1ã¤ä»¥ä¸Šãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹
                  conditionMet = selectedItems.some(item => checkedItems.includes(item));
                  console.log(`âœ“ ã€Œãµãã‚ã‚‹ã€åˆ¤å®š: ${conditionMet ? 'âœ…æ¡ä»¶æº€ãŸã™' : 'âŒæ¡ä»¶æº€ãŸã•ãªã„'}`);
                }
              } else {
                // UNCHECKED = ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„
                if (logic === 'AND') {
                  // ã™ã¹ã¦ã®é …ç›®ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„
                  conditionMet = selectedItems.every(item => !checkedItems.includes(item));
                  console.log(`âœ“ ã€Œã®ã¿ã€+ã€Œãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ã€åˆ¤å®š: ${conditionMet ? 'âœ…æ¡ä»¶æº€ãŸã™' : 'âŒæ¡ä»¶æº€ãŸã•ãªã„'}`);
                } else {
                  // ã„ãšã‚Œã‹ã®é …ç›®ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„
                  conditionMet = selectedItems.some(item => !checkedItems.includes(item));
                  console.log(`âœ“ ã€Œãµãã‚ã‚‹ã€+ã€Œãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ã€åˆ¤å®š: ${conditionMet ? 'âœ…æ¡ä»¶æº€ãŸã™' : 'âŒæ¡ä»¶æº€ãŸã•ãªã„'}`);
                }
              }
            } else {
              console.error('âŒ previewSlideAreaãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
          } else {
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ã®å‡¦ç†ï¼‰
            const op = block.getFieldValue('OP');
            const expectedValue = block.getFieldValue('VALUE');
            
            console.log('ğŸ” æ¡ä»¶ãƒ–ãƒ­ãƒƒã‚¯è©³ç´°:', {
              systemId: sysId,
              elementName: elementName,
              operator: op,
              expectedValue: expectedValue
            });
            
            try {
              // ç¾åœ¨ã®å®Ÿè¡Œç”»é¢ã‹ã‚‰è¦ç´ ã®å€¤ã‚’å–å¾—
              const previewArea = document.getElementById('previewSlideArea');
              if (!previewArea) {
                throw new Error('å®Ÿè¡Œç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
              }
              
              // ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å…¥åŠ›è¦ç´ ã‚’æ¢ã™
              let actualValue = '';
              
              // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ»æ•°å€¤å…¥åŠ›ãƒ»æ—¥æ™‚å…¥åŠ›ã‚’æ¢ã™
              const inputContainers = previewArea.querySelectorAll('.input-container');
              for (const container of inputContainers) {
                const label = container.querySelector('.input-label');
                if (label && label.textContent.trim() === elementName) {
                  const input = container.querySelector('.input-box');
                  if (input) {
                    actualValue = input.value || '';
                    console.log(`ğŸ“ å…¥åŠ›æ¬„ã€Œ${elementName}ã€ã‹ã‚‰å€¤ã‚’å–å¾—: "${actualValue}"`);
                    break;
                  }
                }
              }
              
              // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ã¾ãŸã¯é¸æŠã•ã‚ŒãŸé …ç›®ã®ãƒ©ãƒ™ãƒ«ã§æ¤œç´¢ï¼‰
              if (!actualValue) {
                const checkboxGroups = previewArea.querySelectorAll('.checkbox-group');
                for (const group of checkboxGroups) {
                  const groupLabel = group.querySelector('.checkbox-group-label');
                  const groupLabelText = groupLabel ? groupLabel.textContent.trim() : '';
                  
                  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆã€é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—
                  if (groupLabelText === elementName) {
                    const checkedItems = [];
                    const rows = group.querySelectorAll('.checkbox-row');
                    rows.forEach(row => {
                      const checkbox = row.querySelector('input[type="checkbox"]');
                      const label = row.querySelector('.checkbox-label');
                      if (checkbox && checkbox.checked && label) {
                        checkedItems.push(label.textContent.trim());
                      }
                    });
                    actualValue = checkedItems.join(',');
                    console.log(`ğŸ“ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${elementName}ã€ã‹ã‚‰é¸æŠé …ç›®ã‚’å–å¾—: "${actualValue}"`);
                    break;
                  }
                  
                  // é¸æŠã•ã‚ŒãŸé …ç›®ã®ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆ
                  const rows = group.querySelectorAll('.checkbox-row');
                  for (const row of rows) {
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    const label = row.querySelector('.checkbox-label');
                    if (checkbox && checkbox.checked && label && label.textContent.trim() === expectedValue) {
                      actualValue = label.textContent.trim();
                      console.log(`ğŸ“ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã€Œ${expectedValue}ã€ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™`);
                      break;
                    }
                  }
                  if (actualValue) break;
                }
              }
              
              // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™
              if (!actualValue) {
                const radioGroups = previewArea.querySelectorAll('.radio-group');
                for (const group of radioGroups) {
                  const groupLabel = group.querySelector('.radio-group-label');
                  const groupLabelText = groupLabel ? groupLabel.textContent.trim() : '';
                  
                  // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆã€é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—
                  if (groupLabelText === elementName) {
                    const rows = group.querySelectorAll('.radio-row');
                    for (const row of rows) {
                      const radio = row.querySelector('input[type="radio"]');
                      const label = row.querySelector('.radio-label');
                      if (radio && radio.checked && label) {
                        actualValue = label.textContent.trim();
                        console.log(`ğŸ“ ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${elementName}ã€ã‹ã‚‰é¸æŠé …ç›®ã‚’å–å¾—: "${actualValue}"`);
                        break;
                      }
                    }
                    break;
                  }
                }
              }
              
              // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
              if (!actualValue) {
                const textContainers = previewArea.querySelectorAll('.text-input-container');
                for (const container of textContainers) {
                  const textDiv = container.querySelector('.text-input');
                  if (textDiv && textDiv.textContent.trim() === elementName) {
                    actualValue = textDiv.textContent || '';
                    console.log(`ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã€Œ${elementName}ã€ã‹ã‚‰å€¤ã‚’å–å¾—: "${actualValue}"`);
                    break;
                  }
                }
              }
              
              switch(op) {
                case 'EQ': conditionMet = (actualValue == expectedValue); break;
                case 'NEQ': conditionMet = (actualValue != expectedValue); break;
                case 'GT': conditionMet = (Number(actualValue) > Number(expectedValue)); break;
                case 'LT': conditionMet = (Number(actualValue) < Number(expectedValue)); break;
                case 'GTE': conditionMet = (Number(actualValue) >= Number(expectedValue)); break;
                case 'LTE': conditionMet = (Number(actualValue) <= Number(expectedValue)); break;
                case 'CONTAINS': conditionMet = actualValue.includes(expectedValue); break;
                case 'CHECKED': conditionMet = actualValue !== ''; break;
              }
              
              console.log(`ğŸ” ã€Œ${elementName}ã€ã®å€¤: "${actualValue}" ${conditionMet ? 'âœ“æ¡ä»¶æº€ãŸã™' : 'âœ—æ¡ä»¶æº€ãŸã•ãªã„'} (æœŸå¾…å€¤: "${expectedValue}", æ¼”ç®—å­: ${op})`);
              
            } catch (error) {
              console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error.message);
            }
          }
          
          // æ¡ä»¶ã«å¿œã˜ã¦DOã¾ãŸã¯ELSEã‚’å®Ÿè¡Œ
          if (conditionMet) {
            const doBlock = block.getInputTargetBlock('DO');
            if (doBlock) await processBlock(doBlock);
          } else {
            const elseBlock = block.getInputTargetBlock('ELSE');
            if (elseBlock) await processBlock(elseBlock);
          }
          break;
          
        case 'load_system':
          const loadSysId = block.getFieldValue('SYSTEM_ID');
          console.log(`ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿: ID=${loadSysId}`);
          console.log('ğŸ” ãƒ–ãƒ­ãƒƒã‚¯è©³ç´°:', {
            type: block.type,
            systemIdField: loadSysId,
            allFields: block.inputList.map(input => ({
              name: input.name,
              fieldRow: input.fieldRow.map(f => ({ name: f.name, value: f.getValue() }))
            }))
          });
          if (loadSysId && loadSysId !== '0') {
            if (typeof loadSystemInPreview === 'function') {
              await loadSystemInPreview(loadSysId);
            }
          }
          break;
          
        case 'display_system':
          const displaySysId = block.getFieldValue('SYSTEM_ID');
          console.log(`ğŸ“º ã‚·ã‚¹ãƒ†ãƒ è¡¨ç¤º: ID=${displaySysId}`);
          if (displaySysId && displaySysId !== '0') {
            if (typeof loadSystemInPreview === 'function') {
              await loadSystemInPreview(displaySysId);
            }
          }
          break;
          
        default:
          console.log(`ğŸ”§ ãƒ–ãƒ­ãƒƒã‚¯å®Ÿè¡Œ: ${block.type}`);
      }
      
      const next = block.getNextBlock();
      if (next) await processBlock(next);
    }
    
    // ã™ã¹ã¦ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œ
    for (const b of blocks) {
      await processBlock(b);
    }

    console.log(`âœ… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€Œ${buttonName}ã€ã‚’å®Ÿè¡Œã—ã¾ã—ãŸ`);

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    workspace.dispose();
    tempDiv.remove();

  } catch (error) {
    console.error('âŒ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
    alert('ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
  }
}
</script>
