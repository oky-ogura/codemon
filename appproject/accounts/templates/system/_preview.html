<script>
// ========================================
// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ï¼ˆå®Ÿè¡Œç”»é¢ï¼‰æ©Ÿèƒ½
// ========================================

window.openPreview = function openPreview(){
  if (document.getElementById('previewOverlay')) return;
  const original = document.getElementById('slideArea');
  if (!original) return;

  const overlay = document.createElement('div');
  overlay.id = 'previewOverlay';
  overlay.className = 'preview-overlay';
  overlay.setAttribute('role','dialog');
  overlay.setAttribute('aria-modal','true');

  const header = document.createElement('div');
  header.className = 'preview-header';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'preview-close';
  closeBtn.textContent = 'é–‰ã˜ã‚‹ (Esc)';
  closeBtn.setAttribute('aria-label','é–‰ã˜ã‚‹');
  header.appendChild(closeBtn);

  const areaWrap = document.createElement('div');
  areaWrap.className = 'preview-area';

  const clone = original.cloneNode(true);
  clone.id = 'previewSlideArea';
  const trash = clone.querySelector('#trash');
  if (trash) trash.remove();

  // cloneNode(true)ã¯DOMæ§‹é€ ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŒã€input/textareaã®ç¾åœ¨å€¤ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„
  // æ˜ç¤ºçš„ã«å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
  const originalInputs = original.querySelectorAll('input, textarea');
  const clonedInputs = clone.querySelectorAll('input, textarea');
  originalInputs.forEach((originalInput, index) => {
    if (clonedInputs[index]) {
      clonedInputs[index].value = originalInput.value;
    }
  });

  clone.querySelectorAll('input,textarea').forEach(el => {
    try {
      el.style.resize = 'none';
    } catch(e){}
  });
  clone.querySelectorAll('input[data-only-number="true"]').forEach(inp=>{
    try { attachNumberFilter(inp); } catch(e){ console.error(e); }
  });

  clone.querySelectorAll('.text-input, [contenteditable]').forEach(el => {
    try {
      if (el.classList && el.classList.contains('text-input')) {
        el.setAttribute('contenteditable','false');
      } else {
        el.setAttribute('contenteditable','false');
      }
    } catch(e){}
  });

  clone.querySelectorAll('.drag-handle').forEach(h => h.remove());

  clone.querySelectorAll('.timer-settings-btn').forEach(el => {
    el.style.display = 'none';
  });

  const previewStyle = document.createElement('style');
  previewStyle.textContent = `
    #previewSlideArea * { pointer-events: none !important; }
    #previewSlideArea button,
    #previewSlideArea .draggable-btn,
    #previewSlideArea .timer-btn { pointer-events: auto !important; }
    #previewSlideArea input,
    #previewSlideArea textarea,
    #previewSlideArea .input-box { pointer-events: auto !important; }
    #previewSlideArea .text-input,
    #previewSlideArea .text-input-container { pointer-events: none !important; }
    #previewSlideArea .input-container,
    #previewSlideArea .draggable-btn,
    #previewSlideArea .text-input-container,
    #previewSlideArea .checkbox-group,
    #previewSlideArea .radio-group,
    #previewSlideArea .timer-container { user-select: text !important; }
    #previewSlideArea .input-label,
    #previewSlideArea .text-input,
    #previewSlideArea input,
    #previewSlideArea textarea { outline: none !important; box-shadow: none !important; }
    #previewSlideArea { -webkit-user-select: text !important; user-select: text !important; box-shadow: 0 6px 30px rgba(0,0,0,0.24); }
    #previewSlideArea .timer-settings-btn { display: none !important; }
    #previewSlideArea .checkbox-group-label { display: none !important; }
    #previewSlideArea .radio-group-label { display: none !important; }
  `;
  overlay.appendChild(previewStyle);

  clone.querySelectorAll('button, .draggable-btn').forEach(btn => {
    try {
      if (!btn.classList.contains('timer-btn') && !btn.classList.contains('timer-mode-btn')) {
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        const targetSystemId = newBtn.getAttribute('data-target-system');
        const algorithmId = newBtn.getAttribute('data-algorithm-id');
        const algorithmXml = newBtn.getAttribute('data-algorithm-xml');
        
        console.log('ğŸ”§ ãƒœã‚¿ãƒ³è¨­å®š:', {
          text: newBtn.textContent,
          systemId: targetSystemId,
          algorithmId: algorithmId,
          hasXml: !!algorithmXml,
          xmlLength: algorithmXml ? algorithmXml.length : 0
        });
        
        newBtn.addEventListener('click', async function(e){
          e.stopPropagation();
          
          console.log('ğŸ–±ï¸ ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯:', newBtn.textContent);
          
          if (algorithmId && algorithmXml) {
            console.log('â–¶ï¸ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–‹å§‹:', algorithmId);
            await executeAlgorithmFromButton(algorithmXml, newBtn.textContent);
          } else if (targetSystemId) {
            console.log('ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ é·ç§»:', targetSystemId);
            loadSystemInPreview(targetSystemId);
          } else {
            console.log('âš ï¸ ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ - å‹•ä½œãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          }
        });
      }
    } catch(err) {
      console.error('ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šã‚¨ãƒ©ãƒ¼:', err);
    }
  });

  clone.querySelectorAll('.timer-container').forEach(timer => {
    const startBtn = timer.querySelector('.timer-btn.start');
    const resetBtn = timer.querySelector('.timer-btn.reset');
    const display = timer.querySelector('.timer-display');
    
    if (startBtn) {
      startBtn.onclick = function(e) {
        e.stopPropagation();
        const running = timer.getAttribute('data-timer-running') === 'true';
        const mode = timer.getAttribute('data-timer-mode');
        
        if (!running) {
          if (mode === 'down') {
            const target = parseInt(timer.getAttribute('data-timer-target') || '0');
            if (target === 0) {
              alert('ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã®æ™‚é–“ã‚’è¨­å®šã—ã¦ãã ã•ã„');
              return;
            }
          }
          timer.setAttribute('data-timer-running', 'true');
          startBtn.textContent = "åœæ­¢";
          startBtn.classList.remove('start');
          startBtn.classList.add('pause');
        } else {
          timer.setAttribute('data-timer-running', 'false');
          startBtn.textContent = "é–‹å§‹";
          startBtn.classList.remove('pause');
          startBtn.classList.add('start');
        }
      };
    }
    
    if (resetBtn) {
      resetBtn.onclick = function(e) {
        e.stopPropagation();
        const mode = timer.getAttribute('data-timer-mode');
        timer.setAttribute('data-timer-running', 'false');
        
        if (mode === 'up') {
          timer.setAttribute('data-timer-seconds', '0');
          if (display) display.textContent = "00:00:00";
        } else {
          const target = parseInt(timer.getAttribute('data-timer-target') || '0');
          timer.setAttribute('data-timer-seconds', target.toString());
          if (display) {
            const h = Math.floor(target / 3600);
            const m = Math.floor((target % 3600) / 60);
            const s = target % 60;
            display.textContent = 
              String(h).padStart(2, '0') + ':' +
              String(m).padStart(2, '0') + ':' +
              String(s).padStart(2, '0');
          }
        }
        
        if (startBtn) {
          startBtn.textContent = "é–‹å§‹";
          startBtn.classList.remove('pause');
          startBtn.classList.add('start');
        }
      };
    }
  });

  areaWrap.appendChild(clone);
  
  // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ IDã‚’è¨­å®šï¼ˆç·¨é›†ç”»é¢ã§é–‹ã„ã¦ã„ã‚‹ã‚·ã‚¹ãƒ†ãƒ ï¼‰
  if (existingSystemData && existingSystemData.systemId) {
    clone.dataset.currentSystemId = existingSystemData.systemId;
  }
  
  overlay.appendChild(header);
  overlay.appendChild(areaWrap);
  document.body.appendChild(overlay);

  const prevOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';

  function closeOverlay(){
    try{ overlay.remove(); }catch(err){}
    document.body.style.overflow = prevOverflow || '';
  }
  closeBtn.addEventListener('click', closeOverlay);
  overlay.addEventListener('click', function(evt){
    if (evt.target === overlay) closeOverlay();
  });
  document.addEventListener('keydown', function onEsc(e){
    if (e.key === 'Escape') {
      closeOverlay();
      document.removeEventListener('keydown', onEsc);
    }
  });
}

// ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè¡Œç”»é¢ã«èª­ã¿è¾¼ã‚€é–¢æ•°
window.loadSystemInPreview = async function loadSystemInPreview(systemId) {
  try {
    console.log(`ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ã‚’èª­ã¿è¾¼ã¿ä¸­...`);
    
    // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ IDã‚’å–å¾—
    const previewArea = document.getElementById('previewSlideArea');
    const currentSystemId = previewArea?.dataset?.currentSystemId;
    
    // åŒã˜ã‚·ã‚¹ãƒ†ãƒ ã‚’å†èª­ã¿è¾¼ã¿ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å ´åˆã¯è­¦å‘Šï¼ˆå…¥åŠ›å€¤ãŒå¤±ã‚ã‚Œã‚‹ï¼‰
    if (currentSystemId && currentSystemId === systemId) {
      console.warn(`âš ï¸ ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ã‚¹ãƒ†ãƒ ï¼ˆID: ${systemId}ï¼‰ã‚’å†èª­ã¿è¾¼ã¿ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚å…¥åŠ›å€¤ãŒå¤±ã‚ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`);
    }
    
    const response = await fetch(`/accounts/system/elements/?system_id=${systemId}`);
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚·ã‚¹ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
      } else if (response.status === 401) {
        throw new Error('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
      } else {
        throw new Error(`ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})`);
      }
    }
    
    const data = await response.json();
    console.log('ğŸ“¦ å—ä¿¡ãƒ‡ãƒ¼ã‚¿:', data);
    
    if (!data.success) {
      throw new Error(data.error || 'ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    // previewAreaã¯æ—¢ã«ä¸Šã§å–å¾—æ¸ˆã¿ï¼ˆ236è¡Œç›®ï¼‰ãªã®ã§å†å®£è¨€ä¸è¦
    if (!previewArea) {
      console.error('å®Ÿè¡Œç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      return;
    }
    
    const children = Array.from(previewArea.children);
    children.forEach(child => {
      if (child.id !== 'trash') {
        child.remove();
      }
    });
    
    // èª­ã¿è¾¼ã‚“ã ã‚·ã‚¹ãƒ†ãƒ ã®IDã‚’è¨˜éŒ²
    previewArea.dataset.currentSystemId = systemId;
    
    restoreSystemElementsToPreview(data.elements, previewArea);
    console.log(`âœ… ã‚·ã‚¹ãƒ†ãƒ ID ${systemId} ã®èª­ã¿è¾¼ã¿å®Œäº†`);
    
  } catch (error) {
    console.error('âŒ ã‚·ã‚¹ãƒ†ãƒ ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
    alert('ã‚·ã‚¹ãƒ†ãƒ ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
  }
}

// å®Ÿè¡Œç”»é¢ã«è¦ç´ ã‚’å¾©å…ƒã™ã‚‹é–¢æ•°
window.restoreSystemElementsToPreview = function restoreSystemElementsToPreview(elementsData, targetArea) {
  if (!targetArea) return;
  
  elementsData.forEach(elem => {
    try {
      let element = null;
      
      switch(elem.element_type) {
        case 'text_input':
          element = createPreviewTextInput(elem, false);
          break;
        case 'number_input':
          element = createPreviewTextInput(elem, true);
          break;
        case 'datetime_input':
          element = createPreviewDatetimeInput(elem);
          break;
        case 'checkbox_group':
          element = createPreviewCheckboxGroup(elem);
          break;
        case 'radio_group':
          element = createPreviewRadioGroup(elem);
          break;
        case 'button':
          element = createPreviewButton(elem);
          break;
        case 'text_box':
          element = createPreviewTextBox(elem);
          break;
        case 'roulette':
          element = createPreviewRoulette(elem);
          break;
        case 'timer':
          element = createPreviewTimer(elem);
          break;
      }
      
      if (element) {
        targetArea.appendChild(element);
      }
    } catch (error) {
      console.error('è¦ç´ ã®å¾©å…ƒã«å¤±æ•—:', elem, error);
    }
  });
}

// ä»¥ä¸‹ã€å®Ÿè¡Œç”»é¢ç”¨ã®è¦ç´ ä½œæˆé–¢æ•°
function createPreviewTextInput(elem, onlyNumber) {
  const container = document.createElement("div");
  container.classList.add("input-container");

  const label = document.createElement("div");
  label.classList.add("input-label");
  label.textContent = elem.element_label || (onlyNumber ? "æ•°å­—ï¼š" : "æ–‡å­—ï¼š");

  const placeholder = elem.element_config?.placeholder || (onlyNumber ? "æ•°å­—ã‚’å…¥åŠ›" : "æ–‡å­—ã‚’å…¥åŠ›ï¼ˆæ”¹è¡Œå¯ï¼‰");
  const actualValue = elem.element_value || "";

  if (onlyNumber) {
    const input = document.createElement("input");
    input.type = "text";
    input.inputMode = "numeric";
    input.pattern = "\\d*";
    input.classList.add("input-box");
    input.placeholder = placeholder;
    input.value = actualValue;
    input.setAttribute('data-only-number', 'true');
    container.appendChild(label);
    container.appendChild(input);
    attachNumberFilter(input);
  } else {
    const textarea = document.createElement("textarea");
    textarea.classList.add("input-box");
    textarea.placeholder = placeholder;
    textarea.value = actualValue;
    container.appendChild(label);
    container.appendChild(textarea);
  }

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewDatetimeInput(elem) {
  const container = document.createElement("div");
  container.classList.add("input-container");

  const label = document.createElement("div");
  label.classList.add("input-label");
  label.textContent = elem.element_label || "æ—¥æ™‚ï¼š";

  const input = document.createElement("input");
  input.type = "datetime-local";
  input.style.minWidth = "180px";
  input.style.minHeight = "36px";
  input.style.fontSize = "16px";
  input.style.padding = "4px 8px";
  input.style.boxSizing = "border-box";
  input.classList.add("input-box");
  input.value = elem.element_value || "";

  container.appendChild(label);
  container.appendChild(input);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewCheckboxGroup(elem) {
  const group = document.createElement('div');
  group.className = 'checkbox-group';

  const options = elem.element_config?.options || [];
  options.forEach((optText, i) => {
    const row = document.createElement('div');
    row.className = 'checkbox-row';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.tabIndex = 0;

    const lbl = document.createElement('div');
    lbl.className = 'checkbox-label';
    lbl.textContent = optText;

    row.appendChild(cb);
    row.appendChild(lbl);
    group.appendChild(row);
  });

  group.style.left = elem.position_x + "px";
  group.style.top = elem.position_y + "px";
  if (elem.width) group.style.width = elem.width + "px";
  if (elem.height) group.style.height = elem.height + "px";

  return group;
}

function createPreviewRadioGroup(elem) {
  const group = document.createElement('div');
  group.className = 'radio-group';

  const uniqueName = 'radio_group_' + Date.now() + '_' + Math.floor(Math.random()*1000);
  const options = elem.element_config?.options || [];
  
  options.forEach((optText, i) => {
    const row = document.createElement('div');
    row.className = 'radio-row';

    const rb = document.createElement('input');
    rb.type = 'radio';
    rb.name = uniqueName;
    rb.tabIndex = 0;

    const lbl = document.createElement('div');
    lbl.className = 'radio-label';
    lbl.textContent = optText;

    row.appendChild(rb);
    row.appendChild(lbl);
    group.appendChild(row);
  });

  group.style.left = elem.position_x + "px";
  group.style.top = elem.position_y + "px";
  if (elem.width) group.style.width = elem.width + "px";
  if (elem.height) group.style.height = elem.height + "px";

  return group;
}

function createPreviewButton(elem) {
  const btn = document.createElement("button");
  btn.classList.add("draggable-btn");
  btn.textContent = elem.element_label || "ãƒœã‚¿ãƒ³";

  const styleData = elem.style_data || {};
  if (elem.width) btn.style.width = elem.width + "px";
  if (elem.height) btn.style.height = elem.height + "px";
  if (styleData.background) btn.style.background = styleData.background;
  if (styleData.color) btn.style.color = styleData.color;

  btn.style.left = elem.position_x + "px";
  btn.style.top = elem.position_y + "px";

  const algorithmId = elem.element_config?.algorithm_id;
  const algorithmXml = elem.element_config?.algorithm_xml;
  const targetSystemId = elem.element_config?.target_system_id;
  
  if (algorithmId) btn.setAttribute('data-algorithm-id', algorithmId);
  if (algorithmXml) btn.setAttribute('data-algorithm-xml', algorithmXml);
  if (targetSystemId) btn.setAttribute('data-target-system', targetSystemId);
  
  btn.addEventListener('click', function(e) {
    e.stopPropagation();
    
    if (algorithmId && algorithmXml) {
      console.log('ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œ:', algorithmId);
      executeAlgorithmFromButton(algorithmXml, btn.textContent);
    } else if (targetSystemId) {
      console.log('ã‚·ã‚¹ãƒ†ãƒ é·ç§»:', targetSystemId);
      loadSystemInPreview(targetSystemId);
    }
  });

  return btn;
}

function createPreviewTextBox(elem) {
  const container = document.createElement("div");
  container.classList.add("text-input-container");

  const textDiv = document.createElement("div");
  textDiv.classList.add("text-input");
  textDiv.textContent = elem.element_value || "";

  container.appendChild(textDiv);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewRoulette(elem) {
  const container = document.createElement("div");
  container.classList.add("roulette-container");
  
  const config = elem.element_config || {};
  const items = config.items || ['é …ç›®1', 'é …ç›®2', 'é …ç›®3'];
  
  container.setAttribute('data-roulette-items', JSON.stringify(items));
  container.setAttribute('data-roulette-spinning', 'false');
  
  const wheel = document.createElement("div");
  wheel.classList.add("roulette-wheel");
  wheel.style.position = "relative";
  wheel.style.width = "200px";
  wheel.style.height = "200px";
  wheel.style.transition = "transform 3s cubic-bezier(0.25, 0.1, 0.25, 1)";
  wheel.dataset.currentRotation = "0";
  
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", "200");
  svg.setAttribute("height", "200");
  svg.setAttribute("viewBox", "0 0 200 200");
  
  const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B500', '#52C41A'];
  const centerX = 100;
  const centerY = 100;
  const radius = 95;
  const anglePerSegment = (2 * Math.PI) / items.length;
  
  items.forEach((item, index) => {
    const startAngle = index * anglePerSegment - Math.PI / 2;
    const endAngle = (index + 1) * anglePerSegment - Math.PI / 2;
    
    const x1 = centerX + radius * Math.cos(startAngle);
    const y1 = centerY + radius * Math.sin(startAngle);
    const x2 = centerX + radius * Math.cos(endAngle);
    const y2 = centerY + radius * Math.sin(endAngle);
    
    const largeArcFlag = anglePerSegment > Math.PI ? 1 : 0;
    
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`);
    path.setAttribute("fill", colors[index % colors.length]);
    path.setAttribute("stroke", "#fff");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);
    
    const textAngle = startAngle + anglePerSegment / 2;
    const textRadius = radius * 0.65;
    const textX = centerX + textRadius * Math.cos(textAngle);
    const textY = centerY + textRadius * Math.sin(textAngle);
    
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", textX);
    text.setAttribute("y", textY);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("fill", "#fff");
    text.setAttribute("font-size", "14");
    text.setAttribute("font-weight", "bold");
    text.setAttribute("transform", `rotate(${(textAngle * 180 / Math.PI) + 90}, ${textX}, ${textY})`);
    text.style.textShadow = "1px 1px 2px rgba(0,0,0,0.8)";
    text.textContent = item;
    svg.appendChild(text);
  });
  
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", centerX);
  circle.setAttribute("cy", centerY);
  circle.setAttribute("r", radius);
  circle.setAttribute("fill", "none");
  circle.setAttribute("stroke", "#333");
  circle.setAttribute("stroke-width", "4");
  svg.appendChild(circle);
  
  wheel.appendChild(svg);
  
  const pin = document.createElement("div");
  pin.style.position = "absolute";
  pin.style.top = "-15px";
  pin.style.left = "46%";
  pin.style.transform = "translateX(-50%)";
  pin.style.width = "0";
  pin.style.height = "0";
  pin.style.borderLeft = "10px solid transparent";
  pin.style.borderRight = "10px solid transparent";
  pin.style.borderTop = "20px solid #FF0000";
  pin.style.zIndex = "10";
  pin.style.pointerEvents = "none";
  
  const result = document.createElement("div");
  result.classList.add("roulette-result");
  result.style.marginTop = "10px";
  result.style.padding = "8px";
  result.style.background = "#f0f0f0";
  result.style.borderRadius = "4px";
  result.style.textAlign = "center";
  result.style.fontWeight = "bold";
  result.textContent = "çµæœ: -";
  
  const spinBtn = document.createElement("button");
  spinBtn.classList.add("roulette-btn", "spin");
  spinBtn.textContent = "ã‚¹ãƒ”ãƒ³";
  spinBtn.style.marginTop = "10px";
  spinBtn.style.padding = "8px 20px";
  spinBtn.style.fontSize = "16px";
  spinBtn.style.cursor = "pointer";
  spinBtn.style.position = "relative";
  spinBtn.style.zIndex = "100";
  spinBtn.onclick = function(e) {
    e.stopPropagation();
    const spinning = container.getAttribute('data-roulette-spinning') === 'true';
    if (spinning) return;
    
    container.setAttribute('data-roulette-spinning', 'true');
    spinBtn.disabled = true;
    spinBtn.style.cursor = 'not-allowed';
    spinBtn.style.opacity = '0.6';
    
    const currentRotation = parseFloat(wheel.dataset.currentRotation) || 0;
    const spins = 5 + Math.random() * 3;
    const extraDegrees = Math.random() * 360;
    const newRotation = currentRotation + spins * 360 + extraDegrees;
    
    wheel.style.transform = `rotate(${newRotation}deg)`;
    wheel.dataset.currentRotation = newRotation;
    
    setTimeout(() => {
      const finalAngle = ((newRotation % 360) + 360) % 360;
      const segmentAngle = 360 / items.length;
      const angleOnWheel = (270 - finalAngle + 360) % 360;
      const selectedIndex = Math.floor((angleOnWheel + 90) / segmentAngle) % items.length;
      
      result.textContent = `çµæœ: ${items[selectedIndex]}`;
      container.setAttribute('data-roulette-spinning', 'false');
      spinBtn.disabled = false;
      spinBtn.style.cursor = 'pointer';
      spinBtn.style.opacity = '1';
    }, 3000);
  };
  
  const wheelWrapper = document.createElement("div");
  wheelWrapper.style.position = "relative";
  wheelWrapper.style.pointerEvents = "none";
  wheelWrapper.appendChild(pin);
  wheelWrapper.appendChild(wheel);
  
  container.appendChild(wheelWrapper);
  container.appendChild(result);
  container.appendChild(spinBtn);
  
  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  return container;
}

function createPreviewTimer(elem) {
  const container = document.createElement('div');
  container.className = 'timer-container';
  
  const config = elem.element_config || {};
  const mode = config.mode || 'countup';
  const initialTime = config.initial_time || 0;
  
  container.setAttribute('data-timer-mode', mode);
  container.setAttribute('data-timer-running', 'false');
  container.setAttribute('data-timer-value', initialTime.toString());
  container.setAttribute('data-initial-time', initialTime.toString());

  const display = document.createElement('div');
  display.className = 'timer-display';
  display.textContent = formatTimerDisplay(initialTime);

  const btnContainer = document.createElement('div');
  btnContainer.className = 'timer-buttons';

  const startBtn = document.createElement('button');
  startBtn.className = 'timer-btn start';
  startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';

  const resetBtn = document.createElement('button');
  resetBtn.className = 'timer-btn reset';
  resetBtn.textContent = 'ãƒªã‚»ãƒƒãƒˆ';

  btnContainer.appendChild(startBtn);
  btnContainer.appendChild(resetBtn);

  container.appendChild(display);
  container.appendChild(btnContainer);

  container.style.left = elem.position_x + "px";
  container.style.top = elem.position_y + "px";
  if (elem.width) container.style.width = elem.width + "px";
  if (elem.height) container.style.height = elem.height + "px";

  setupTimerEvents(container, startBtn, resetBtn, display, mode, initialTime);

  return container;
}

function setupTimerEvents(container, startBtn, resetBtn, display, mode, initialTime) {
  let intervalId = null;

  startBtn.onclick = function(e) {
    e.stopPropagation();
    const running = container.getAttribute('data-timer-running') === 'true';
    
    if (running) {
      if (intervalId) clearInterval(intervalId);
      container.setAttribute('data-timer-running', 'false');
      startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
    } else {
      container.setAttribute('data-timer-running', 'true');
      startBtn.textContent = 'ã‚¹ãƒˆãƒƒãƒ—';
      
      intervalId = setInterval(() => {
        let currentValue = parseInt(container.getAttribute('data-timer-value')) || 0;
        
        if (mode === 'countdown') {
          currentValue = Math.max(0, currentValue - 1);
          container.setAttribute('data-timer-value', currentValue.toString());
          display.textContent = formatTimerDisplay(currentValue);
          
          if (currentValue === 0) {
            if (intervalId) clearInterval(intervalId);
            container.setAttribute('data-timer-running', 'false');
            startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
          }
        } else {
          currentValue += 1;
          container.setAttribute('data-timer-value', currentValue.toString());
          display.textContent = formatTimerDisplay(currentValue);
        }
      }, 1000);
    }
  };

  resetBtn.onclick = function(e) {
    e.stopPropagation();
    if (intervalId) clearInterval(intervalId);
    container.setAttribute('data-timer-running', 'false');
    container.setAttribute('data-timer-value', initialTime.toString());
    display.textContent = formatTimerDisplay(initialTime);
    startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
  };
}

function formatTimerDisplay(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return String(h).padStart(2, '0') + ':' + 
         String(m).padStart(2, '0') + ':' + 
         String(s).padStart(2, '0');
}

// ç¾åœ¨ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¨ãƒªã‚¢ã®è¦ç´ ã‚’åé›†ã™ã‚‹é–¢æ•°
window.collectCurrentElements = function collectCurrentElements() {
  const slide = document.getElementById('slideArea');
  if (!slide) return [];
  
  const elements = [];
  
  // ãƒ†ã‚­ã‚¹ãƒˆ/æ•°å€¤/æ—¥æ™‚å…¥åŠ›
  slide.querySelectorAll('.input-container').forEach(container => {
    const label = container.querySelector('.input-label');
    const input = container.querySelector('.input-box');
    const labelText = label ? label.textContent.trim() : '';
    const inputValue = input ? input.value.trim() : '';
    const placeholder = input ? input.placeholder : '';
    const onlyNumber = input && input.getAttribute('data-only-number') === 'true';
    const isDatetime = input && input.type === 'datetime-local';
    
    let elementType = 'text_input';
    if (onlyNumber) elementType = 'number_input';
    if (isDatetime) elementType = 'datetime_input';
    
    elements.push({
      element_type: elementType,
      element_label: labelText,
      element_value: inputValue,
      position_x: parseInt(container.style.left) || 0,
      position_y: parseInt(container.style.top) || 0,
      width: container.offsetWidth || null,
      height: container.offsetHeight || null,
      style_data: {},
      element_config: {
        placeholder: placeholder
      }
    });
  });
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—
  slide.querySelectorAll('.checkbox-group').forEach(group => {
    const groupLabelDiv = group.querySelector('.checkbox-group-label');
    const groupLabel = groupLabelDiv ? groupLabelDiv.textContent.trim() : '';
    
    const rows = group.querySelectorAll('.checkbox-row');
    const options = [];
    rows.forEach(row => {
      const label = row.querySelector('.checkbox-label');
      if (label) options.push(label.textContent.trim());
    });
    
    elements.push({
      element_type: 'checkbox_group',
      element_label: groupLabel,
      element_value: '',
      position_x: parseInt(group.style.left) || 0,
      position_y: parseInt(group.style.top) || 0,
      width: group.offsetWidth || null,
      height: group.offsetHeight || null,
      style_data: {},
      element_config: { options: options }
    });
  });
  
  // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
  slide.querySelectorAll('.radio-group').forEach(group => {
    const groupLabelDiv = group.querySelector('.radio-group-label');
    const groupLabel = groupLabelDiv ? groupLabelDiv.textContent.trim() : '';
    
    const rows = group.querySelectorAll('.radio-row');
    const options = [];
    rows.forEach(row => {
      const label = row.querySelector('.radio-label');
      if (label) options.push(label.textContent.trim());
    });
    
    elements.push({
      element_type: 'radio_group',
      element_label: groupLabel,
      element_value: '',
      position_x: parseInt(group.style.left) || 0,
      position_y: parseInt(group.style.top) || 0,
      width: group.offsetWidth || null,
      height: group.offsetHeight || null,
      style_data: {},
      element_config: { options: options }
    });
  });
  
  // ãƒœã‚¿ãƒ³
  slide.querySelectorAll('.draggable-btn').forEach(btn => {
    const targetSystemId = btn.getAttribute('data-target-system');
    const algorithmId = btn.getAttribute('data-algorithm-id');
    const algorithmXml = btn.getAttribute('data-algorithm-xml');
    let buttonText = btn.textContent.trim();
    buttonText = buttonText.replace(/â‰¡/g, '').trim();
    
    elements.push({
      element_type: 'button',
      element_label: buttonText,
      element_value: '',
      position_x: parseInt(btn.style.left) || 0,
      position_y: parseInt(btn.style.top) || 0,
      width: parseInt(btn.style.width) || null,
      height: parseInt(btn.style.height) || null,
      style_data: {
        background: btn.style.background || btn.style.backgroundColor,
        color: btn.style.color
      },
      element_config: {
        target_system_id: targetSystemId,
        algorithm_id: algorithmId,
        algorithm_xml: algorithmXml
      }
    });
  });
  
  // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹
  slide.querySelectorAll('.text-input-container').forEach(container => {
    const textInput = container.querySelector('.text-input');
    const content = textInput ? (textInput.value || textInput.textContent || '').trim() : '';
    
    elements.push({
      element_type: 'text_box',
      element_label: '',
      element_value: content,
      position_x: parseInt(container.style.left) || 0,
      position_y: parseInt(container.style.top) || 0,
      width: parseInt(container.style.width) || null,
      height: parseInt(container.style.height) || null,
      style_data: {},
      element_config: {}
    });
  });
  
  // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ
  slide.querySelectorAll('.roulette-container').forEach(roulette => {
    const items = JSON.parse(roulette.getAttribute('data-roulette-items') || '[]');
    
    elements.push({
      element_type: 'roulette',
      element_label: '',
      element_value: '',
      position_x: parseInt(roulette.style.left) || 0,
      position_y: parseInt(roulette.style.top) || 0,
      width: parseInt(roulette.style.width) || null,
      height: parseInt(roulette.style.height) || null,
      style_data: {},
      element_config: {
        items: items
      }
    });
  });
  
  // ã‚¿ã‚¤ãƒãƒ¼
  slide.querySelectorAll('.timer-container').forEach(timer => {
    const mode = timer.getAttribute('data-timer-mode') || 'countup';
    const initialTime = parseInt(timer.getAttribute('data-initial-time')) || 0;
    
    elements.push({
      element_type: 'timer',
      element_label: '',
      element_value: '',
      position_x: parseInt(timer.style.left) || 0,
      position_y: parseInt(timer.style.top) || 0,
      width: parseInt(timer.style.width) || null,
      height: parseInt(timer.style.height) || null,
      style_data: {},
      element_config: {
        mode: mode,
        initial_time: initialTime
      }
    });
  });
  
  return elements;
}

// ========================================
// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–¢æ•°
// ========================================
window.executeAlgorithmFromButton = async function executeAlgorithmFromButton(blocklyXml, buttonName) {
  console.log('ğŸ¯ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œé–‹å§‹:', buttonName);
  
  if (!blocklyXml) {
    alert('ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    return;
  }

  // BlocklyãŒã¾ã ãƒ­ãƒ¼ãƒ‰ä¸­ã®å ´åˆã¯ã€loadBlockly()ã‚’å¾…æ©Ÿ
  if (typeof Blockly === 'undefined') {
    console.log('â³ Blocklyã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...');
    try {
      await loadBlockly();
      console.log('âœ… Blockly loaded successfully');
    } catch (error) {
      console.error('âŒ Blockly loading failed:', error);
      const retry = confirm('Blocklyã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚\n\nãƒªãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ');
      if (retry) {
        location.reload();
      }
      return;
    }
  }
  
  console.log('âœ… Blockly ready, executing algorithm');

  try {
    // éè¡¨ç¤ºã®Blocklyãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½œæˆ
    const tempDiv = document.createElement('div');
    tempDiv.style.display = 'none';
    document.body.appendChild(tempDiv);

    const workspace = Blockly.inject(tempDiv, {
      toolbox: '<xml></xml>'
    });

    // ã‚«ã‚¹ã‚¿ãƒ ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®šç¾©
    if (!Blockly.Blocks['load_system']) {
      Blockly.Blocks['load_system'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚ˆã¿ã“ã‚€:")
            .appendField(new Blockly.FieldTextInput("0"), "SYSTEM_ID");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
        }
      };
    }

    if (!Blockly.Blocks['system_condition']) {
      Blockly.Blocks['system_condition'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ã‚‚ã— ã‚·ã‚¹ãƒ†ãƒ ")
            .appendField(new Blockly.FieldTextInput("0"), "SYSTEM_ID")
            .appendField("ã®");
          this.appendDummyInput()
            .appendField("ãƒ©ãƒ™ãƒ«ï¼š")
            .appendField(new Blockly.FieldTextInput("æ–‡å­—ï¼š"), "ELEMENT_NAME")
            .appendField("ãŒ");
          this.appendDummyInput()
            .appendField(new Blockly.FieldDropdown([
              ["=", "EQ"],
              ["â‰ ", "NEQ"],
              [">", "GT"],
              ["<", "LT"],
              ["â‰§", "GTE"],
              ["â‰¦", "LTE"],
              ["å«ã‚€", "CONTAINS"]
            ]), "OP")
            .appendField(new Blockly.FieldTextInput("ã‚ãŸã„"), "VALUE")
            .appendField("ãªã‚‰");
          this.appendStatementInput("DO")
            .appendField("ã™ã‚‹ã“ã¨");
          this.appendStatementInput("ELSE")
            .appendField("ãã†ã§ãªã‘ã‚Œã°");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
        }
      };
    }

    if (!Blockly.Blocks['display_system']) {
      Blockly.Blocks['display_system'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ã‚·ã‚¹ãƒ†ãƒ ã‚’ã²ã‚‡ã†ã˜:")
            .appendField(new Blockly.FieldTextInput("0"), "SYSTEM_ID");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(290);
        }
      };
    }

    if (!Blockly.Blocks['text_block']) {
      Blockly.Blocks['text_block'] = {
        init: function() {
          this.appendDummyInput()
            .appendField("ãƒ†ã‚­ã‚¹ãƒˆ:")
            .appendField(new Blockly.FieldTextInput("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"), "message");
          this.setPreviousStatement(true);
          this.setNextStatement(true);
          this.setColour(160);
        }
      };
    }

    // XMLã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’èª­ã¿è¾¼ã‚€
    const xml = Blockly.utils.xml.textToDom(blocklyXml);
    Blockly.Xml.domToWorkspace(xml, workspace);

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç›´æ¥å‡¦ç†
    const blocks = workspace.getTopBlocks(true);
    
    // processBlocké–¢æ•°ã‚’å®šç¾©
    async function processBlock(block) {
      if (!block) return;
      
      switch(block.type) {
        case 'text_block':
          const msg = block.getFieldValue('message') || '';
          console.log('ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆ:', msg);
          break;
          
        case 'system_condition':
          const sysId = block.getFieldValue('SYSTEM_ID');
          const elementName = block.getFieldValue('ELEMENT_NAME');
          const op = block.getFieldValue('OP');
          const expectedValue = block.getFieldValue('VALUE');
          
          console.log('ğŸ” æ¡ä»¶ãƒ–ãƒ­ãƒƒã‚¯è©³ç´°:', {
            systemId: sysId,
            elementName: elementName,
            operator: op,
            expectedValue: expectedValue
          });
          
          try {
            // ç¾åœ¨ã®å®Ÿè¡Œç”»é¢ã‹ã‚‰è¦ç´ ã®å€¤ã‚’å–å¾—
            const previewArea = document.getElementById('previewSlideArea');
            if (!previewArea) {
              throw new Error('å®Ÿè¡Œç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            // ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å…¥åŠ›è¦ç´ ã‚’æ¢ã™
            let actualValue = '';
            
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ»æ•°å€¤å…¥åŠ›ãƒ»æ—¥æ™‚å…¥åŠ›ã‚’æ¢ã™
            const inputContainers = previewArea.querySelectorAll('.input-container');
            for (const container of inputContainers) {
              const label = container.querySelector('.input-label');
              if (label && label.textContent.trim() === elementName) {
                const input = container.querySelector('.input-box');
                if (input) {
                  actualValue = input.value || '';
                  console.log(`ğŸ“ å…¥åŠ›æ¬„ã€Œ${elementName}ã€ã‹ã‚‰å€¤ã‚’å–å¾—: "${actualValue}"`);
                  break;
                }
              }
            }
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ã¾ãŸã¯é¸æŠã•ã‚ŒãŸé …ç›®ã®ãƒ©ãƒ™ãƒ«ã§æ¤œç´¢ï¼‰
            if (!actualValue) {
              const checkboxGroups = previewArea.querySelectorAll('.checkbox-group');
              for (const group of checkboxGroups) {
                const groupLabel = group.querySelector('.checkbox-group-label');
                const groupLabelText = groupLabel ? groupLabel.textContent.trim() : '';
                
                // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆã€é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—
                if (groupLabelText === elementName) {
                  const checkedItems = [];
                  const rows = group.querySelectorAll('.checkbox-row');
                  rows.forEach(row => {
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    const label = row.querySelector('.checkbox-label');
                    if (checkbox && checkbox.checked && label) {
                      checkedItems.push(label.textContent.trim());
                    }
                  });
                  actualValue = checkedItems.join(',');
                  console.log(`ğŸ“ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${elementName}ã€ã‹ã‚‰é¸æŠé …ç›®ã‚’å–å¾—: "${actualValue}"`);
                  break;
                }
                
                // é¸æŠã•ã‚ŒãŸé …ç›®ã®ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆ
                const rows = group.querySelectorAll('.checkbox-row');
                for (const row of rows) {
                  const checkbox = row.querySelector('input[type="checkbox"]');
                  const label = row.querySelector('.checkbox-label');
                  if (checkbox && checkbox.checked && label && label.textContent.trim() === expectedValue) {
                    actualValue = label.textContent.trim();
                    console.log(`ğŸ“ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã€Œ${expectedValue}ã€ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™`);
                    break;
                  }
                }
                if (actualValue) break;
              }
            }
            
            // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™
            if (!actualValue) {
              const radioGroups = previewArea.querySelectorAll('.radio-group');
              for (const group of radioGroups) {
                const groupLabel = group.querySelector('.radio-group-label');
                const groupLabelText = groupLabel ? groupLabel.textContent.trim() : '';
                
                // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ãŒä¸€è‡´ã™ã‚‹å ´åˆã€é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—
                if (groupLabelText === elementName) {
                  const rows = group.querySelectorAll('.radio-row');
                  for (const row of rows) {
                    const radio = row.querySelector('input[type="radio"]');
                    const label = row.querySelector('.radio-label');
                    if (radio && radio.checked && label) {
                      actualValue = label.textContent.trim();
                      console.log(`ğŸ“ ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${elementName}ã€ã‹ã‚‰é¸æŠé …ç›®ã‚’å–å¾—: "${actualValue}"`);
                      break;
                    }
                  }
                  break;
                }
              }
            }
            
            // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
            if (!actualValue) {
              const textContainers = previewArea.querySelectorAll('.text-input-container');
              for (const container of textContainers) {
                const textDiv = container.querySelector('.text-input');
                if (textDiv && textDiv.textContent.trim() === elementName) {
                  actualValue = textDiv.textContent || '';
                  console.log(`ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã€Œ${elementName}ã€ã‹ã‚‰å€¤ã‚’å–å¾—: "${actualValue}"`);
                  break;
                }
              }
            }
            
            let conditionMet = false;
            switch(op) {
              case 'EQ': conditionMet = (actualValue == expectedValue); break;
              case 'NEQ': conditionMet = (actualValue != expectedValue); break;
              case 'GT': conditionMet = (Number(actualValue) > Number(expectedValue)); break;
              case 'LT': conditionMet = (Number(actualValue) < Number(expectedValue)); break;
              case 'GTE': conditionMet = (Number(actualValue) >= Number(expectedValue)); break;
              case 'LTE': conditionMet = (Number(actualValue) <= Number(expectedValue)); break;
              case 'CONTAINS': conditionMet = actualValue.includes(expectedValue); break;
            }
            
            console.log(`ğŸ” ã€Œ${elementName}ã€ã®å€¤: "${actualValue}" ${conditionMet ? 'âœ“æ¡ä»¶æº€ãŸã™' : 'âœ—æ¡ä»¶æº€ãŸã•ãªã„'} (æœŸå¾…å€¤: "${expectedValue}", æ¼”ç®—å­: ${op})`);
            
            if (conditionMet) {
              const doBlock = block.getInputTargetBlock('DO');
              if (doBlock) await processBlock(doBlock);
            } else {
              const elseBlock = block.getInputTargetBlock('ELSE');
              if (elseBlock) await processBlock(elseBlock);
            }
          } catch (error) {
            console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error.message);
          }
          break;
          
        case 'load_system':
          const loadSysId = block.getFieldValue('SYSTEM_ID');
          console.log(`ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿: ID=${loadSysId}`);
          console.log('ğŸ” ãƒ–ãƒ­ãƒƒã‚¯è©³ç´°:', {
            type: block.type,
            systemIdField: loadSysId,
            allFields: block.inputList.map(input => ({
              name: input.name,
              fieldRow: input.fieldRow.map(f => ({ name: f.name, value: f.getValue() }))
            }))
          });
          if (loadSysId && loadSysId !== '0') {
            if (typeof loadSystemInPreview === 'function') {
              await loadSystemInPreview(loadSysId);
            }
          }
          break;
          
        case 'display_system':
          const displaySysId = block.getFieldValue('SYSTEM_ID');
          console.log(`ğŸ“º ã‚·ã‚¹ãƒ†ãƒ è¡¨ç¤º: ID=${displaySysId}`);
          if (displaySysId && displaySysId !== '0') {
            if (typeof loadSystemInPreview === 'function') {
              await loadSystemInPreview(displaySysId);
            }
          }
          break;
          
        default:
          console.log(`ğŸ”§ ãƒ–ãƒ­ãƒƒã‚¯å®Ÿè¡Œ: ${block.type}`);
      }
      
      const next = block.getNextBlock();
      if (next) await processBlock(next);
    }
    
    // ã™ã¹ã¦ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œ
    for (const b of blocks) {
      await processBlock(b);
    }

    console.log(`âœ… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€Œ${buttonName}ã€ã‚’å®Ÿè¡Œã—ã¾ã—ãŸ`);

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    workspace.dispose();
    tempDiv.remove();

  } catch (error) {
    console.error('âŒ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
    alert('ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
  }
}
</script>
