<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚·ã‚¹ãƒ†ãƒ ä½œæˆ</title>
  <style>
    :root { --nav-height:56px; --primary:#1976d2; --bg:#f9f9fb; --muted:#666; }
    .top-nav {
      box-sizing:border-box;
      width:100%;
      max-width:980px;
      height:var(--nav-height);
      margin:16px auto 8px;
      display:flex;
      align-items:center;
      gap:12px;
      padding:6px 12px;
      background:linear-gradient(180deg,#fff,#fafafa);
      border-radius:10px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
      border:1px solid #e6e6e9;
    }
    .nav-brand{
      display:flex;
      align-items:center;
      gap:8px;
      margin-right:8px;
      padding-right:8px;
      border-right:1px solid #eee;
    }
    .nav-brand .logo{
      width:36px;
      height:36px;
      border-radius:6px;
      background:var(--primary);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:700;
      font-size:18px;
    }
    .nav-brand .title{
      font-size:15px;
      color:#111;
      font-weight:600;
    }
    .nav-tabs{
      display:flex;
      justify-content: space-evenly;
      align-items:center;
      width:100%;
    }
    .nav-tab{
      appearance:none;
      border:0;
      background:transparent;
      padding:8px 12px;
      border-radius:8px;
      font-size:14px;
      cursor:pointer;
      color:var(--muted);
      transition: all .12s ease;
    }
    .nav-tab:hover{
      background:#f0f6ff;
      color:var(--primary);
      transform:translateY(-1px);
    }
    .nav-tab.active{
      background:var(--primary);
      color:#fff;
      box-shadow:0 2px 6px rgba(25,118,210,0.18);
    }

    body {
      font-family: sans-serif;
      margin: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    .button-bar {
      width: 860px;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
    }

    .button-bar button {
      margin-right: 10px;
      font-size: 16px;
      padding: 6px 18px;
      border-radius: 4px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
      transition: background 0.2s;
    }
    .button-bar button:hover {
      background: #e0e0e0;
    }

    .button-bar button.active {
      background:#1976d2;
      color:#fff;
      box-shadow:0 6px 16px rgba(25,118,210,0.12);
    }

    .shortcut-bar {
      width: 860px;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 16px;
      margin-top: 0;
    }
    .shortcut-bar button {
      margin-right: 10px;
      font-size: 18px;
      padding: 6px 18px;
      border-radius: 4px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
      transition: background 0.2s;
    }
    .shortcut-bar button:hover {
      background: #e0e0e0;
    }
    .shortcut-bar .shortcut-label {
      font-size: 14px;
      color: #555;
      margin-right: 20px;
    }

    /* æ—¢å­˜ã®é’ã„ä¿å­˜ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå‚ç…§ç”¨ï¼‰ */
    .shortcut-save {
      padding: 10px 18px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid rgba(10,59,110,0.08);
      background: linear-gradient(180deg,#cfe7ff,#b6d9ff);
      color: #0a3b6e;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 16px rgba(10,59,110,0.06);
      margin-left: 6px;
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .shortcut-save:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(10,59,110,0.10);
    }
    .shortcut-save[aria-disabled="true"]{
      opacity: 0.7;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    /* ã”å¸Œæœ›ã®ç·‘ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå„ªå…ˆçš„ã«é©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å…·ä½“åŒ–ï¼‰ */
    .shortcut-bar .shortcut-btns #saveBtn {
      font-size: 18px;
      margin-left: 8px;
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 4px 14px;
      cursor: pointer;
    }
    .shortcut-bar .shortcut-btns #saveBtn:hover {
      background: #1e7e34;
    }


    /* Run/å®Ÿè¡Œ ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ã‚’çµ±ä¸€ */
    .shortcut-bar .shortcut-btns #executeBtn {
      font-size: 18px;
      margin-left: 10px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 4px 16px;
      cursor: pointer;
    }
    .shortcut-bar .shortcut-btns #executeBtn:hover {
      background: #0056b3;
    }
    #slideArea {
      width: 860px;
      height: 440px;
      border: 2px dashed #666;
      position: relative;
      background-color: #fdfdfd;
      overflow: hidden;
      margin: 0 auto;
      display: block;
    }

    .input-container {
      position: absolute;
      display: flex;
      align-items: center;
      min-width: 180px;
      min-height: 40px;
      cursor: grab;
      box-sizing: border-box;
      left: 0;
      top: 0;
    }

    .input-container.grabbing { cursor: grabbing; }

    .input-label {
      margin-right: 5px;
      white-space: nowrap;
      padding: 2px 4px;
      border: 1px dashed transparent;
      min-width: 40px;
    }
    .input-label[contenteditable="true"]:focus {
      outline: none;
      border: 1px dashed #999;
      background: #f0f0f0;
    }

    .input-box {
      resize: both;
      overflow: auto;
      min-width: 120px;
      min-height: 40px;
      padding: 5px;
      box-sizing: border-box;
    }

    .draggable-btn {
      position: absolute;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: grab;
      min-width: 60px;
      min-height: 30px;
      box-sizing: border-box;
    }
    .draggable-btn.grabbing { cursor: grabbing; }
    .draggable-btn:hover {
      filter: brightness(0.9);
    }
    /* drag handle */
    .drag-handle {
      position: absolute;
      left: -10px;
      top: -10px;
      width: 20px;
      height: 20px;
      border-radius: 4px;
      background: rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      color: rgba(0,0,0,0.6);
      cursor: grab;
      user-select: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      z-index: 1000;
    }
    .drag-handle:active { cursor: grabbing; }
    .drag-handle.hidden { display:none; }

    #slideArea #trash {
      position: absolute;
      right: 12px;
      top: 12px;
      width: 52px;
      height: 52px;
      background: #eee;
      border: 2px solid #888;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: #888;
      z-index: 2000;
      transition: background 0.2s, color 0.2s;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      user-select: none;
    }
    #slideArea #trash.dragover {
      background: #ffdddd;
      color: #d32f2f;
      border-color: #d32f2f;
    }

    /* è¿½è¨˜ç”¨ CSS: é¸æŠçŸ©å½¢ã¨ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ */
    .textarea-selection {
      position: absolute;
      border: 2px dashed rgba(25,118,210,0.9);
      background: rgba(25,118,210,0.07);
      z-index: 1500;
      pointer-events: none;
      box-sizing:border-box;
    }

    /* éé¸æŠæ™‚ã¯ã‚³ãƒ³ãƒ†ãƒŠæ ã‚’éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆè¦æœ›ï¼‰ */
    .text-input-container {
      position: absolute;
      box-sizing: border-box;
      z-index: 1200;
      display: block;
      min-width: 40px;
      min-height: 24px;
      border: none;           /* éé¸æŠæ™‚ã¯æ ã‚’æ¶ˆã™ */
      background: transparent;
      cursor: grab;           /* ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ */
      overflow: auto;
      /* ã‚³ãƒ³ãƒ†ãƒŠè‡ªä½“ã§ãƒªã‚µã‚¤ã‚ºã•ã›ã‚‹ï¼ˆå†…å´ã®è¦ç´ ã¯ãƒªã‚µã‚¤ã‚ºä¸å¯ã«ã™ã‚‹ï¼‰ */
      resize: both;
    }
    .text-input-container.grabbing { cursor: grabbing; }

    /* ãƒ†ã‚­ã‚¹ãƒˆè‡ªä½“ã¯ã‚³ãƒ³ãƒ†ãƒŠã«åˆã‚ã›ã¦ä¼¸ç¸®ã—ã€å€‹åˆ¥ã®ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã¯æŒãŸãªã„ */
    .text-input {
      width: 100%;
      height: 100%;
      padding: 6px 8px;
      box-sizing: border-box;
      /* å†…å´ã¯ãƒªã‚µã‚¤ã‚ºã‚’ç„¡åŠ¹åŒ–ã—ã¦ã€ã‚³ãƒ³ãƒ†ãƒŠã®ãƒªã‚µã‚¤ã‚ºã ã‘ã«ã™ã‚‹ */
      resize: none !important;
      overflow: auto;
      outline: none;
      border: none;           /* éé¸æŠæ™‚ã¯æ ã‚’æ¶ˆã™ */
      background: rgba(255,255,255,0.96);
      font-size: 14px;
      line-height: 1.4;
      min-height: 20px;
      min-width: 20px;
      display: block;
    }

    /* ç·¨é›†ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼‰æ™‚ã«ã®ã¿æ ï¼å½±ã‚’è¡¨ç¤ºï¼ˆã‚»ãƒ¬ã‚¯ã‚¿ä¿®æ­£æ¸ˆã¿ï¼‰ */
    .text-input-container:focus-within {
      border: 1px dashed rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.98);
      box-shadow: 0 6px 18px rgba(25,118,210,0.04);
      cursor: text;
    }
    .text-input_container:focus-within .text-input {
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.98);
    }

    /* è¡¨ç¤ºç”¨ã®ãƒªã‚µã‚¤ã‚ºä¸­ã‚¯ãƒ©ã‚¹ï¼ˆè¦–è¦šã®ãƒ’ãƒ³ãƒˆã€ä»»æ„ï¼‰ */
    .text-input-container.resizing {
      box-shadow: 0 0 0 2px rgba(25,118,210,0.06) inset;
      pointer-events: auto;
      cursor: nwse-resize;
    }

    /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚ˆã‚Šç”»é¢å…¨ä½“ã«è¡¨ç¤ºï¼‰ */
    .preview-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      flex-direction: column;
      z-index: 9999;
      align-items: stretch;
      justify-content: center;
      padding: 8px;                 /* å°‘ãªã‚ã®ä½™ç™½ã§ã‚ˆã‚Šå…¨ç”»é¢ã«è¦‹ã›ã‚‹ */
      box-sizing:border-box;
    }
    .preview-header {
      height: 48px;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      z-index: 10010;
    }
    .preview-close {
      background:#fff;
      border:1px solid #ccc;
      padding:6px 12px;
      border-radius:6px;
      cursor:pointer;
      font-weight:600;
    }
    .preview-area {
      flex:1;
      background:transparent;
      border-radius:6px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:4px;                  /* è»½ã„å†…å´ä½™ç™½ */
      box-sizing:border-box;
    }
    /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã»ã¼å…¨ç”»é¢è¡¨ç¤ºã«ã™ã‚‹ï¼ˆmax åˆ¶é™ã‚’é™¤å»ï¼‰ */
    #previewSlideArea {
      width: calc(100vw - 16px);    /* å·¦å³ã«å°ã•ãªä½™ç™½ã‚’æ®‹ã™ */
      height: calc(100vh - 72px);   /* ãƒ˜ãƒƒãƒ€åˆ†ã¨ä¸Šä¸‹ã«ä½™ç™½ã‚’æ®‹ã™ */
      max-width: none;
      max-height: none;
      border: 2px dashed #666;
      position:relative;
      background:#fff;
      box-sizing:border-box;
      border-radius:6px;
      overflow:auto;
    }

    @media (max-width:980px){
      .button-bar, .shortcut-bar, #slideArea { width: 92%; max-width:860px; }
      #previewSlideArea { width: calc(100vw - 8px); height: calc(100vh - 72px); }
    }
  </style>
</head>
<body>
  <header class="top-nav" role="banner" aria-label="ãƒ¡ã‚¤ãƒ³ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³">
    <nav class="nav-tabs" role="navigation" aria-label="ã‚¿ãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼">
      <button type="button" class="nav-tab active" id="tab-system" aria-pressed="true" title="ã‚·ã‚¹ãƒ†ãƒ ">ã‚·ã‚¹ãƒ†ãƒ </button>
      <button type="button" class="nav-tab" id="tab-algorithm" aria-pressed="false" title="ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </button>
      <button type="button" class="nav-tab" id="tab-progress" aria-pressed="false" title="é€²æ—ç¢ºèª">é€²æ—ç¢ºèª</button>
      <button type="button" class="nav-tab" id="tab-account" aria-pressed="false" title="ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ">ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ</button>
    </nav>
  </header>

  <h1>ã‚·ã‚¹ãƒ†ãƒ ä½œæˆ</h1>
  <div class="button-bar">
    <button id="addTextBtn">ã‚ã„ã†</button>
    <button id="addNumberBtn">123</button>
    <button id="addDatetimeBtn">æ—¥æ™‚</button>
    <button id="addButtonBtn">ãƒœã‚¿ãƒ³è¿½åŠ </button>
  </div>

  <div class="shortcut-bar">
    <button id="undoBtn" title="å…ƒã«æˆ»ã™ (Ctrl+Z)">â†</button>
    <button id="redoBtn" title="ã‚„ã‚Šç›´ã— (Ctrl+Y)">â†’</button>

    <div class="shortcut-btns" aria-hidden="false">
      <button id="executeBtn" aria-disabled="false">å®Ÿè¡Œ</button>
      <button id="saveBtn" aria-disabled="false">ä¿å­˜</button>
    </div>
  </div>

  <div id="slideArea">
    <div id="trash" title="ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ã§å‰Šé™¤">ğŸ—‘ï¸</div>
  </div>

  <script>
    (function(){
      try{
        const tabs = document.querySelectorAll('.nav-tab');
        tabs.forEach(tab=>{
          tab.addEventListener('click', (e)=>{
            try{
              tabs.forEach(t=>{
                t.classList.remove('active');
                t.setAttribute('aria-pressed','false');
              });
              tab.classList.add('active');
              tab.setAttribute('aria-pressed','true');
              if(typeof tab.blur === 'function') tab.blur();

              if(tab.id === 'tab-system'){
                // ã‚·ã‚¹ãƒ†ãƒ ã‚¿ãƒ–æŠ¼ä¸‹ã§ã‚·ã‚¹ãƒ†ãƒ é¸æŠç”»é¢ã«é·ç§»
                window.location.href = '/accounts/system/choice/';
                return;
              }
              if(tab.id === 'tab-algorithm'){
                window.location.href = 'http://127.0.0.1:8000/accounts/block/';
                return;
              }
            }catch(err){
              console.error('tab click handler error', err);
            }
          });
        });
      }catch(err){
        console.error('tabs init error', err);
      }
    })();

    const colorOptions = [
      { name: "ã‚ãŠ", value: "#2196F3" },
      { name: "ã‚ã‹", value: "#F44336" },
      { name: "ã¿ã©ã‚Š", value: "#4CAF50" },
      { name: "ãã„ã‚", value: "#FFEB3B", textColor: "#333" },
      { name: "ã‚ªãƒ¬ãƒ³ã‚¸", value: "#FF9800" },
      { name: "ã‚€ã‚‰ã•ã", value: "#9C27B0" },
      { name: "ãã‚", value: "#333" },
      { name: "ã—ã‚", value: "#fff", textColor: "#333" }
    ];

    let history = [];
    let historyIndex = -1;

    function saveHistory() {
      const slide = document.getElementById("slideArea");
      history = history.slice(0, historyIndex + 1);
      history.push(slide.innerHTML);
      historyIndex++;
    }

    function restoreHistory(index) {
      const slide = document.getElementById("slideArea");
      slide.innerHTML = history[index];
      Array.from(slide.children).forEach(el => {
        if (el.classList.contains("input-container") || el.classList.contains("draggable-btn") || el.classList.contains("text-input-container")) {
          addDragHandleIfMissing(el);
          makeDraggable(el);
        }
      });
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        restoreHistory(historyIndex);
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreHistory(historyIndex);
      }
    }

    document.getElementById("undoBtn").addEventListener("click", undo);
    document.getElementById("redoBtn").addEventListener("click", redo);
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === "z") {
        e.preventDefault();
        undo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
        e.preventDefault();
        redo();
      }
    });

    // ä¿å­˜ãƒœã‚¿ãƒ³: ã‚¯ãƒªãƒƒã‚¯ã§ã‚·ã‚¹ãƒ†ãƒ ä¿å­˜ç”»é¢ã¸é·ç§»
    const saveBtn = document.getElementById('saveBtn');
    if (saveBtn) {
      saveBtn.addEventListener('click', function(e){
        e.preventDefault();
        window.location.href = '/accounts/system/save/';
      });
    }
    // å®Ÿè¡Œãƒœã‚¿ãƒ³: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å…¨ç”»é¢ã§è¡¨ç¤ºã—ã€ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã¯ç·¨é›†ãƒ»ãƒªã‚µã‚¤ã‚ºä¸å¯ã¨ã™ã‚‹
    const executeBtn = document.getElementById('executeBtn');
    if (executeBtn) {
      executeBtn.addEventListener('click', function(e){
        e.preventDefault();
        openPreview();
      });
    }

    // small helper: add drag handle if missing
    function addDragHandleIfMissing(container) {
      if (!container || container.querySelector('.drag-handle')) return;
      const handle = document.createElement('div');
      handle.className = 'drag-handle';
      handle.title = 'ç§»å‹•';
      handle.textContent = 'â‰¡';
      container.appendChild(handle);
    }

    // æ±ç”¨: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã§ä½¿ã†ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ï¼ˆè¦ªã‚³ãƒ³ãƒ†ãƒŠã‚’æŒ‡å®šï¼‰ â€” æ—¢å­˜ã®ãŸã‚æ®‹ã™ãŒã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã¯ä½¿ç”¨ã—ãªã„
    function makeDraggableForPreview(el, parent) {
      let offsetX=0, offsetY=0, dragging=false;
      el.style.position = 'absolute';
      el.addEventListener('mousedown', function(evt){
        if (evt.button !== 0) return;
        if (evt.target && (evt.target.classList && (evt.target.classList.contains('input-label') || evt.target.classList.contains('input-box') || evt.target.classList.contains('text-input')))) {
          return;
        }
        evt.preventDefault();
        const parentRect = parent.getBoundingClientRect();
        const elRect = el.getBoundingClientRect();
        offsetX = evt.clientX - elRect.left;
        offsetY = evt.clientY - elRect.top;
        dragging = true;
        document.body.style.userSelect = 'none';
        el.style.zIndex = 2000;
      });
      function onMove(evt){
        if (!dragging) return;
        const parentRect = parent.getBoundingClientRect();
        let x = evt.clientX - parentRect.left - offsetX;
        let y = evt.clientY - parentRect.top - offsetY;
        x = Math.max(0, Math.min(x, parent.clientWidth - el.offsetWidth));
        y = Math.max(0, Math.min(y, parent.clientHeight - el.offsetHeight));
        el.style.left = x + 'px';
        el.style.top = y + 'px';
      }
      function onUp(evt){
        if (dragging) {
          dragging = false;
          el.style.zIndex = '';
          document.body.style.userSelect = '';
        }
      }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    }

    // æ”¹è‰¯ç‰ˆ makeDraggable:
    // - ãƒãƒ³ãƒ‰ãƒ«ã§ã®ãƒ‰ãƒ©ãƒƒã‚°ã‚’ã‚µãƒãƒ¼ãƒˆ
    // - ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒªã‚µã‚¤ã‚ºï¼ˆè¦ç´ ã®ã‚µã‚¤ã‚ºå¤‰æ›´ï¼‰ä¸­ã¯ä½ç½®ã‚’å›ºå®šã™ã‚‹ï¼ˆç§»å‹•ã‚’ç„¡åŠ¹åŒ–ï¼‰
    function makeDraggable(el) {
      if (!el) return;
      el.style.position = 'absolute';
      addDragHandleIfMissing(el);

      const handle = el.querySelector('.drag-handle');
      let dragging = false;
      let startX = 0, startY = 0;
      let offsetX = 0, offsetY = 0;
      let moved = false;
      const threshold = 5; // px

      // ãƒªã‚µã‚¤ã‚ºæ¤œå‡ºãƒ•ãƒ©ã‚°ã¨ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã‚¿ã‚¤ãƒãƒ¼
      let resizing = false;
      let resizeTimer = null;

      // åˆæœŸã‚µã‚¤ã‚ºï¼ˆmousedown æ™‚ç‚¹ï¼‰ã‚’ä¿æŒã—ã¦ç°¡æ˜“åˆ¤å®šã«ä½¿ã†
      let initialWidth = el.offsetWidth;
      let initialHeight = el.offsetHeight;

      // ResizeObserver ã‚’ä½¿ç”¨ã—ã¦ã‚µã‚¤ã‚ºå¤‰åŒ–ã‚’æ¤œå‡º â†’ ãƒªã‚µã‚¤ã‚ºä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
      let ro = null;
      try {
        ro = new ResizeObserver(() => {
          // ã‚µã‚¤ã‚ºå¤‰åŒ–ãŒæ¥ãŸã‚‰ãƒªã‚µã‚¤ã‚ºä¸­ã¨ã¿ãªã™
          resizing = true;
          el.classList.add('resizing');
          if (resizeTimer) clearTimeout(resizeTimer);
          // ã‚µã‚¤ã‚ºå¤‰åŒ–ãŒæ­¢ã¾ã£ã¦ã‹ã‚‰ 120ms ã§ãƒªã‚µã‚¤ã‚ºå®Œäº†ã¨åˆ¤æ–­
          resizeTimer = setTimeout(() => {
            resizing = false;
            el.classList.remove('resizing');
            resizeTimer = null;
            // æ›´æ–°ã•ã‚ŒãŸå¹…é«˜ã•ã‚’è¨˜éŒ²ã—ã¦ãŠã
            initialWidth = el.offsetWidth;
            initialHeight = el.offsetHeight;
          }, 120);
        });
        // è¦³å¯Ÿå¯¾è±¡ã¯ã‚³ãƒ³ãƒ†ãƒŠè‡ªèº«ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã¯ã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒªã‚µã‚¤ã‚ºã™ã‚‹æƒ³å®šï¼‰
        ro.observe(el);
      } catch (err) {
        ro = null;
      }

      function setGrabbing(state){
        if (state) {
          el.classList.add('grabbing');
          if (el.classList.contains('draggable-btn')) el.classList.add('grabbing');
        } else {
          el.classList.remove('grabbing');
          if (el.classList.contains('draggable-btn')) el.classList.remove('grabbing');
        }
      }

      function onDown(clientX, clientY, isHandle) {
        // ã‚¯ãƒªãƒƒã‚¯ã—ãŸè¦ç´ ãŒç·¨é›†å¯èƒ½ãªã‚‰ã€ãƒãƒ³ãƒ‰ãƒ«ä»¥å¤–ã§ã¯ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã—ãªã„
        const active = document.elementFromPoint(clientX, clientY);
        if (active) {
          if (active.classList && (active.classList.contains('input-box') || active.classList.contains('text-input') || active.classList.contains('input-label') || active.getAttribute('contenteditable') === 'true')) {
            if (!isHandle) return false;
          }
        }
        const elRect = el.getBoundingClientRect();
        offsetX = clientX - elRect.left;
        offsetY = clientY - elRect.top;
        startX = clientX;
        startY = clientY;
        moved = false;
        document.body.style.userSelect = 'none';

        // mousedown æ™‚ç‚¹ã§ã®ã‚µã‚¤ã‚ºã‚’ä¿æŒï¼ˆãƒã‚¦ã‚¹æ“ä½œã§ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒªã‚µã‚¤ã‚ºé–‹å§‹åˆ¤å®šã«åˆ©ç”¨ï¼‰
        initialWidth = el.offsetWidth;
        initialHeight = el.offsetHeight;

        return true;
      }

      function startDrag() {
        if (resizing) return; // ãƒªã‚µã‚¤ã‚ºä¸­ã¯ãƒ‰ãƒ©ãƒƒã‚°ã—ãªã„
        dragging = true;
        setGrabbing(true);
        el.style.zIndex = 1000;
      }

      function stopDrag(dropX, dropY) {
        if (dragging) {
          const trash = document.getElementById("trash");
          if (trash) {
            const trashRect = trash.getBoundingClientRect();
            if (dropX > trashRect.left && dropX < trashRect.right && dropY > trashRect.top && dropY < trashRect.bottom) {
              if (el.parentNode) el.parentNode.removeChild(el);
              saveHistory();
            }
            trash.classList.remove('dragover');
          }
        }
        dragging = false;
        setGrabbing(false);
        el.style.zIndex = '';
        document.body.style.userSelect = '';
      }

      // mouse events
      function mousedownHandler(e) {
        if (e.button !== 0) return;
        const isHandle = e.target === handle || e.target.closest('.drag-handle');
        if (!onDown(e.clientX, e.clientY, isHandle)) return;

        const onMoveWhileDown = function(ev){
          // ã¾ãšã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒªã‚µã‚¤ã‚ºãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ç°¡æ˜“åˆ¤å®šï¼ˆã‚µã‚¤ã‚ºå·®ç•°ï¼‰
          if (!resizing && (el.offsetWidth !== initialWidth || el.offsetHeight !== initialHeight)) {
            resizing = true;
            el.classList.add('resizing');
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              resizing = false;
              el.classList.remove('resizing');
              resizeTimer = null;
              initialWidth = el.offsetWidth;
              initialHeight = el.offsetHeight;
            }, 120);
          }

          // ãƒªã‚µã‚¤ã‚ºä¸­ã¯ä½ç½®ã‚’å¤‰æ›´ã—ãªã„ï¼ˆãƒ•ã‚©ãƒ¼ãƒ ã¨åŒæ§˜ã«å›ºå®šï¼‰
          if (resizing) {
            return;
          }

          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          if (!moved && Math.hypot(dx, dy) >= threshold) {
            moved = true;
            startDrag();
          }
          if (dragging) {
            const slide = document.getElementById("slideArea");
            const slideRect = slide.getBoundingClientRect();
            let x = ev.clientX - slideRect.left - offsetX;
            let y = ev.clientY - slideRect.top - offsetY;
            x = Math.max(0, Math.min(x, slide.clientWidth - el.offsetWidth));
            y = Math.max(0, Math.min(y, slide.clientHeight - el.offsetHeight));
            el.style.left = x + "px";
            el.style.top = y + "px";

            const trash = document.getElementById("trash");
            const trashRect = trash.getBoundingClientRect();
            if (
              ev.clientX > trashRect.left &&
              ev.clientX < trashRect.right &&
              ev.clientY > trashRect.top &&
              ev.clientY < trashRect.bottom
            ) {
              trash.classList.add("dragover");
            } else {
              trash.classList.remove("dragover");
            }
          }
        };
        const onUpWhileDown = function(ev){
          stopDrag(ev.clientX, ev.clientY);
          document.removeEventListener('mousemove', onMoveWhileDown);
          document.removeEventListener('mouseup', onUpWhileDown);
        };
        document.addEventListener('mousemove', onMoveWhileDown);
        document.addEventListener('mouseup', onUpWhileDown);
      }

      // touch events
      function touchstartHandler(e) {
        if (!e.touches || e.touches.length === 0) return;
        const touch = e.touches[0];
        const isHandle = e.target === handle || e.target.closest('.drag-handle');
        if (!onDown(touch.clientX, touch.clientY, isHandle)) return;
        const onTouchMove = function(ev){
          const t = ev.touches[0];

          // touch ã§ã‚‚ã‚µã‚¤ã‚ºå·®ã§ãƒªã‚µã‚¤ã‚ºåˆ¤å®š
          if (!resizing && (el.offsetWidth !== initialWidth || el.offsetHeight !== initialHeight)) {
            resizing = true;
            el.classList.add('resizing');
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              resizing = false;
              el.classList.remove('resizing');
              resizeTimer = null;
              initialWidth = el.offsetWidth;
              initialHeight = el.offsetHeight;
            }, 120);
          }
          if (resizing) return;

          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
          if (!moved && Math.hypot(dx, dy) >= threshold) {
            moved = true;
            startDrag();
          }
          if (dragging) {
            const slide = document.getElementById("slideArea");
            const slideRect = slide.getBoundingClientRect();
            let x = t.clientX - slideRect.left - offsetX;
            let y = t.clientY - slideRect.top - offsetY;
            x = Math.max(0, Math.min(x, slide.clientWidth - el.offsetWidth));
            y = Math.max(0, Math.min(y, slide.clientHeight - el.offsetHeight));
            el.style.left = x + "px";
            el.style.top = y + "px";
          }
        };
        const onTouchEnd = function(ev){
          const last = ev.changedTouches && ev.changedTouches[0];
          stopDrag(last ? last.clientX : startX, last ? last.clientY : startY);
          document.removeEventListener('touchmove', onTouchMove);
          document.removeEventListener('touchend', onTouchEnd);
        };
        document.addEventListener('touchmove', onTouchMove, {passive:false});
        document.addEventListener('touchend', onTouchEnd);
      }

      // attach handlers to handle and container
      handle.addEventListener('mousedown', mousedownHandler);
      el.addEventListener('mousedown', mousedownHandler);

      handle.addEventListener('touchstart', touchstartHandler, {passive:true});
      el.addEventListener('touchstart', touchstartHandler, {passive:true});

      // cleanup on element removal: disconnect observer if any
      const mo = new MutationObserver(mutations => {
        if (!document.body.contains(el)) {
          try { if (ro) ro.disconnect(); } catch(e){}
          try { mo.disconnect(); } catch(e){}
        }
      });
      mo.observe(document.body, {childList: true, subtree: true});
    }

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¦è¡¨ç¤ºï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã¯æç”»ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã¯éç·¨é›†ãƒ»éãƒªã‚µã‚¤ã‚ºã€ãã®ä»–ãƒ•ã‚©ãƒ¼ãƒ ã¯å…¥åŠ›å¯ï¼‰
    function openPreview(){
      if (document.getElementById('previewOverlay')) return;
      const original = document.getElementById('slideArea');
      if (!original) return;

      // overlay elements
      const overlay = document.createElement('div');
      overlay.id = 'previewOverlay';
      overlay.className = 'preview-overlay';
      overlay.setAttribute('role','dialog');
      overlay.setAttribute('aria-modal','true');

      const header = document.createElement('div');
      header.className = 'preview-header';

      const closeBtn = document.createElement('button');
      closeBtn.className = 'preview-close';
      closeBtn.textContent = 'é–‰ã˜ã‚‹ (Esc)';
      closeBtn.setAttribute('aria-label','é–‰ã˜ã‚‹');
      header.appendChild(closeBtn);

      const areaWrap = document.createElement('div');
      areaWrap.className = 'preview-area';

      // clone slideArea and adjust
      const clone = original.cloneNode(true);
      clone.id = 'previewSlideArea';
      // remove trash if exists
      const trash = clone.querySelector('#trash');
      if (trash) trash.remove();

      // --- å¤‰æ›´: inputs/textareas ã‚’ã€Œå…¥åŠ›å¯èƒ½ã€ã«ã™ã‚‹ï¼ˆpointer-events: autoï¼‰ã€ãŸã ã—æç”»ãƒ†ã‚­ã‚¹ãƒˆï¼ˆ.text-inputï¼‰ã¯éç·¨é›†ã«ã™ã‚‹ ---
      // Enable native form controls in preview (allow typing)
      clone.querySelectorAll('input,textarea').forEach(el => {
        try {
          // remove any disabled/readOnly that may have been cloned
          el.removeAttribute('disabled');
          el.readOnly = false;
          el.style.pointerEvents = 'auto';
          // prevent native resize handles in preview UI
          el.style.resize = 'none';
        } catch(e){}
      });
      // For elements that were contenteditable but are "drawn text boxes" (.text-input), keep them non-editable.
      clone.querySelectorAll('.text-input, [contenteditable]').forEach(el => {
        try {
          // If it's specifically the drawn text-input element (class .text-input), keep it non-editable.
          if (el.classList && el.classList.contains('text-input')) {
            el.removeAttribute('contenteditable');
            el.setAttribute('aria-readonly','true');
            el.style.pointerEvents = 'none';
          } else {
            // For other contenteditable elements (e.g. labels), make them non-editable (display-only) in preview
            el.removeAttribute('contenteditable');
            el.setAttribute('aria-readonly','true');
            el.style.pointerEvents = 'none';
          }
        } catch(e){}
      });

      // Remove drag handles in preview (no move)
      clone.querySelectorAll('.drag-handle').forEach(h => h.remove());

      // Inject preview-only style:
      const previewStyle = document.createElement('style');
      previewStyle.textContent = `
        /* åŸºæœ¬: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã§ã¯ã»ã¨ã‚“ã©ã®è¦ç´ ã¸ã®æ“ä½œã‚’ç„¡åŠ¹åŒ– */
        #previewSlideArea * { pointer-events: none !important; }

        /* ãƒœã‚¿ãƒ³é¡ã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§æœ‰åŠ¹ã«ã™ã‚‹ */
        #previewSlideArea button,
        #previewSlideArea .draggable-btn {
          pointer-events: auto !important;
        }

        /* ãƒã‚¤ãƒ†ã‚£ãƒ–ã® input / textarea / input-box ã¯å…¥åŠ›ï¼ˆtypingï¼‰ã‚’è¨±å¯ */
        #previewSlideArea input,
        #previewSlideArea textarea,
        #previewSlideArea .input-box {
          pointer-events: auto !important;
          user-select: text !important;
        }

        /* æç”»ã—ã¦é…ç½®ã—ãŸãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ï¼ˆ.text-inputï¼‰ã¯è¡¨ç¤ºã®ã¿ï¼ˆç·¨é›†ãƒ»ãƒªã‚µã‚¤ã‚ºä¸å¯ï¼‰ */
        #previewSlideArea .text-input,
        #previewSlideArea .text-input-container {
          pointer-events: none !important;
          resize: none !important;
        }

        /* è¦ªã‚³ãƒ³ãƒ†ãƒŠï¼ãƒœã‚¿ãƒ³ç­‰ã®ç§»å‹•ã‚„ãƒ‰ãƒ©ãƒƒã‚°ã‚’è¦‹ãŸç›®ä¸Šã‚‚ç„¡åŠ¹åŒ– */
        #previewSlideArea .input-container,
        #previewSlideArea .draggable-btn,
        #previewSlideArea .text-input-container {
          cursor: default !important;
          user-select: text !important;
        }

        /* ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã®è¦‹ãŸç›®ã‚’æŠ‘ãˆã‚‹ï¼ˆå…¥åŠ›ä¸å¯ãªã‚‚ã®ã¯æ ã‚’è¡¨ç¤ºã—ãªã„ï¼‰ */
        #previewSlideArea .input-label,
        #previewSlideArea .text-input,
        #previewSlideArea input,
        #previewSlideArea textarea {
          outline: none !important;
          background: transparent !important;
        }

        /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é ˜åŸŸè¡¨ç¤ºã®èª¿æ•´ */
        #previewSlideArea { -webkit-user-select: text !important; user-select: text !important; box-shadow: 0 6px 30px rgba(0,0,0,0.24); }
      `;
      overlay.appendChild(previewStyle);

      // Reattach simple click handlers for cloned buttons so they work in preview
      clone.querySelectorAll('button, .draggable-btn').forEach(btn => {
        try {
          btn.style.pointerEvents = 'auto';
          btn.addEventListener('click', function(ev){
            ev.stopPropagation();
            const label = (btn.textContent || 'ãƒœã‚¿ãƒ³').trim();
            try { alert('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼šãƒœã‚¿ãƒ³ã€Œ' + label + 'ã€ãŒæŠ¼ã•ã‚Œã¾ã—ãŸ'); } catch(e){}
          });
        } catch(err) {}
      });

      // Append clone
      areaWrap.appendChild(clone);
      overlay.appendChild(header);
      overlay.appendChild(areaWrap);
      document.body.appendChild(overlay);

      // prevent background scrolling while preview open
      const prevOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';

      // close handlers
      function closeOverlay(){
        try{ overlay.remove(); }catch(err){}
        document.body.style.overflow = prevOverflow || '';
      }
      closeBtn.addEventListener('click', closeOverlay);
      overlay.addEventListener('click', function(evt){
        if (evt.target === overlay) closeOverlay();
      });
      document.addEventListener('keydown', function onEsc(e){
        if (e.key === 'Escape') {
          closeOverlay();
          document.removeEventListener('keydown', onEsc);
        }
      });
    }

    function getRandomPosition(width=100, height=40) {
      const slide = document.getElementById("slideArea");
      const x = Math.random() * Math.max(0, slide.clientWidth - width);
      const y = Math.random() * Math.max(0, slide.clientHeight - height);
      return {x, y};
    }

    function createInput(defaultLabel, placeholder, onlyNumber=false) {
      let container = document.createElement("div");
      container.classList.add("input-container");

      let label = document.createElement("div");
      label.classList.add("input-label");
      label.textContent = defaultLabel;
      label.contentEditable = "true";

      let textarea = document.createElement("textarea");
      textarea.classList.add("input-box");
      textarea.placeholder = placeholder;

      if (onlyNumber) {
        textarea.addEventListener("input", function() {
          this.value = this.value.replace(/[^0-9\n]/g, "");
        });
      }

      container.appendChild(label);
      container.appendChild(textarea);

      let pos = getRandomPosition();
      container.style.left = pos.x + "px";
      container.style.top = pos.y + "px";
      // add handle then make draggable
      addDragHandleIfMissing(container);
      makeDraggable(container);
      document.getElementById("slideArea").appendChild(container);
      saveHistory();
    }

    function createDatetimeInput() {
      let container = document.createElement("div");
      container.classList.add("input-container");

      let label = document.createElement("div");
      label.classList.add("input-label");
      label.textContent = "æ—¥æ™‚ï¼š";
      label.contentEditable = "true";

      let input = document.createElement("input");
      input.type = "datetime-local";
      input.style.minWidth = "180px";
      input.style.minHeight = "36px";
      input.style.fontSize = "16px";
      input.style.padding = "4px 8px";
      input.style.boxSizing = "border-box";
      input.classList.add("input-box");

      container.appendChild(label);
      container.appendChild(input);

      let pos = getRandomPosition(240, 40);
      container.style.left = pos.x + "px";
      container.style.top = pos.y + "px";
      addDragHandleIfMissing(container);
      makeDraggable(container);
      document.getElementById("slideArea").appendChild(container);
      saveHistory();
    }

    function createButton(labelText, width, height, color, textColor) {
      let btn = document.createElement("button");
      btn.classList.add("draggable-btn");
      btn.textContent = labelText;

      btn.style.width = width + "px";
      btn.style.height = height + "px";
      btn.style.background = color;
      btn.style.color = textColor || "#fff";

      let isDragging = false;
      let startX, startY;

      btn.addEventListener("mousedown", function(e) {
        startX = e.clientX;
        startY = e.clientY;
        isDragging = false;
      });

      document.addEventListener("mousemove", function(e) {
        if (startX !== undefined &&
            (Math.abs(e.clientX - startX) > 3 || Math.abs(e.clientY - startY) > 3)) {
          isDragging = true;
        }
      });

      btn.addEventListener("mouseup", function(e) {
        if (!isDragging) {
          alert("ãƒœã‚¿ãƒ³ã€Œ" + btn.textContent + "ã€ãŒæŠ¼ã•ã‚Œã¾ã—ãŸ");
        }
        startX = undefined;
        startY = undefined;
      });

      let pos = getRandomPosition(width, height);
      btn.style.left = pos.x + "px";
      btn.style.top = pos.y + "px";
      // add handle and make draggable
      addDragHandleIfMissing(btn);
      makeDraggable(btn);
      document.getElementById("slideArea").appendChild(btn);
      saveHistory();
    }

    document.getElementById("addTextBtn").addEventListener("click", function() {
      createInput("æ–‡å­—ï¼š", "æ–‡å­—ã‚’å…¥åŠ›ï¼ˆæ”¹è¡Œã§ãã¾ã™ï¼‰");
    });

    document.getElementById("addNumberBtn").addEventListener("click", function() {
      createInput("æ•°å­—ï¼š", "æ•°å­—ã‚’å…¥åŠ›ï¼ˆæ”¹è¡Œå¯ï¼‰", true);
    });

    document.getElementById("addDatetimeBtn").addEventListener("click", function() {
      createDatetimeInput();
    });

    document.getElementById("addButtonBtn").addEventListener("click", function() {
      let name = prompt("ãƒœã‚¿ãƒ³ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", "ãƒœã‚¿ãƒ³");
      if (!name) return;

      let width = parseInt(prompt("ãƒœã‚¿ãƒ³ã®å¹…(px)", "100"));
      let height = parseInt(prompt("ãƒœã‚¿ãƒ³ã®é«˜ã•(px)", "40"));
      if (isNaN(width) || isNaN(height)) {
        alert("æ•°å€¤ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      let colorNameList = colorOptions.map(opt => opt.name).join(" / ");
      let colorName = prompt(
        "ãƒœã‚¿ãƒ³ã®è‰²ã‚’é¸ã‚“ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š\n" + colorNameList,
        colorOptions[0].name
      );
      if (!colorName) colorName = colorOptions[0].name;
      let colorObj = colorOptions.find(opt => opt.name === colorName);
      if (!colorObj) {
        alert("è‰²ã®åå‰ã¯ã€Œ" + colorNameList + "ã€ã‹ã‚‰é¸ã‚“ã§ãã ã•ã„ã€‚");
        return;
      }

      createButton(name, width, height, colorObj.value, colorObj.textColor);
    });

    window.onload = function() {
      // add handles to existing elements (if any) and ensure draggables
      Array.from(document.querySelectorAll('.input-container, .draggable-btn, .text-input-container')).forEach(el=>{
        addDragHandleIfMissing(el);
        makeDraggable(el);
      });
      saveHistory();
    };
  </script>

  <!-- ã“ã“ã‹ã‚‰è¿½åŠ : PowerPointé¢¨ã«é¸æŠç¯„å›²ã§ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã§ãã‚‹æ©Ÿèƒ½ -->
  <script>
    (function(){
      const slide = document.getElementById('slideArea');
      const buttonBar = document.querySelector('.button-bar');
      if (!slide || !buttonBar) return;

      // ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
      const drawBtn = document.createElement('button');
      drawBtn.id = 'drawTextBtn';
      drawBtn.textContent = 'ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹';
      drawBtn.title = 'ãƒ‰ãƒ©ãƒƒã‚°ã§é¸æŠã—ã¦ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’ä½œæˆ';
      buttonBar.appendChild(drawBtn);

      let drawing = false;
      let startX = 0, startY = 0;
      let selRect = null;

      function toLocalCoords(clientX, clientY) {
        const rect = slide.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        return {x, y};
      }

      function startDrawing(e) {
        if (!drawing) return;
        // å·¦ãƒœã‚¿ãƒ³ã®ã¿
        if (e.button !== 0) return;
        const coords = toLocalCoords(e.clientX, e.clientY);
        startX = Math.max(0, Math.min(slide.clientWidth, coords.x));
        startY = Math.max(0, Math.min(slide.clientHeight, coords.y));
        selRect = document.createElement('div');
        selRect.className = 'textarea-selection';
        selRect.style.left = startX + 'px';
        selRect.style.top = startY + 'px';
        selRect.style.width = '0px';
        selRect.style.height = '0px';
        slide.appendChild(selRect);
        document.addEventListener('mousemove', onMouseMoveDuringDraw);
        document.addEventListener('mouseup', onMouseUpAfterDraw);
      }

      function onMouseMoveDuringDraw(e) {
        if (!selRect) return;
        const coords = toLocalCoords(e.clientX, e.clientY);
        let curX = Math.max(0, Math.min(slide.clientWidth, coords.x));
        let curY = Math.max(0, Math.min(slide.clientHeight, coords.y));
        const left = Math.min(startX, curX);
        const top = Math.min(startY, curY);
        const w = Math.max(2, Math.abs(curX - startX));
        const h = Math.max(2, Math.abs(curY - startY));
        selRect.style.left = left + 'px';
        selRect.style.top = top + 'px';
        selRect.style.width = w + 'px';
        selRect.style.height = h + 'px';
      }

      function onMouseUpAfterDraw(e) {
        document.removeEventListener('mousemove', onMouseMoveDuringDraw);
        document.removeEventListener('mouseup', onMouseUpAfterDraw);
        if (!selRect) return;
        const rect = selRect.getBoundingClientRect();
        const slideRect = slide.getBoundingClientRect();
        // compute local coords
        const left = rect.left - slideRect.left;
        const top = rect.top - slideRect.top;
        const width = rect.width;
        const height = rect.height;
        selRect.remove();
        selRect = null;

        // ignore tiny selections
        if (width < 10 || height < 10) {
          return;
        }

        // create text box container
        const container = document.createElement('div');
        container.classList.add('text-input-container');
        container.style.left = Math.max(0, Math.min(slide.clientWidth - 10, left)) + 'px';
        container.style.top = Math.max(0, Math.min(slide.clientHeight - 10, top)) + 'px';
        container.style.width = Math.min(slide.clientWidth - left, width) + 'px';
        container.style.height = Math.min(slide.clientHeight - top, height) + 'px';

        const textDiv = document.createElement('div');
        textDiv.classList.add('text-input', 'input-box');
        textDiv.contentEditable = 'true';
        textDiv.innerHTML = ''; // start empty
        container.appendChild(textDiv);

        slide.appendChild(container);
        // add handle + make draggable
        addDragHandleIfMissing(container);
        try { makeDraggable(container); } catch (err) { console.error(err); }

        // focus for immediate editing
        setTimeout(() => {
          textDiv.focus();
          // place caret at end
          const range = document.createRange();
          range.selectNodeContents(textDiv);
          range.collapse(false);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        }, 10);

        // save history
        try { saveHistory(); } catch (err) { console.error(err); }
      }

      // toggle drawing mode
      drawBtn.addEventListener('click', function(){
        drawing = !drawing;
        drawBtn.classList.toggle('active', drawing);
        slide.style.cursor = drawing ? 'crosshair' : '';
        // ensure any in-progress selection is cleared
        if (!drawing && selRect) {
          selRect.remove();
          selRect = null;
        }
      });

      // start mousedown on slide only when drawing mode active
      slide.addEventListener('mousedown', function(e){
        // don't interfere with dragging existing elements
        // if target is an existing control, ignore
        if (!drawing) return;
        // if clicking on an existing interactive element, ignore
        if (e.target && (e.target.closest('.input-container') || e.target.closest('.draggable-btn') || e.target.closest('.text-input-container'))) {
          return;
        }
        startDrawing(e);
      });

      // cancel drawing with Escape
      document.addEventListener('keydown', function(e){
        if (e.key === 'Escape' && drawing) {
          drawing = false;
          drawBtn.classList.remove('active');
          slide.style.cursor = '';
          if (selRect) { selRect.remove(); selRect = null; }
        }
      });

      // on window resize, cancel drawing
      window.addEventListener('resize', function(){
        if (selRect) { selRect.remove(); selRect = null; }
      });

    })();
  </script>

</body>
</html>