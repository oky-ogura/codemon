{% extends 'base.html' %}
{% load static %}

{% block content %}
<style>
  /* „É¨„Ç§„Ç¢„Ç¶„Éà: „Çµ„Ç§„Éâ„Éê„Éº + „ÉÅ„É£„ÉÉ„Éà */
  .chat-layout {
    display: flex;
    gap: 20px;
    max-width: 1100px;
    margin: 0 auto;
    padding: 20px;
    box-sizing: border-box;
  }

  .chat-sidebar {
    width: 240px;
    background: #ffffff;
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    display: flex;
    flex-direction: column;
    gap: 8px;
    height: calc(100vh - 100px - 40px);
    overflow-y: auto;
  }

  .chat-sidebar h4 {
    margin: 0 0 8px 0;
    font-size: 1.0em;
  }

  .chat-sidebar a {
    display: block;
    padding: 8px 10px;
    color: #333;
    text-decoration: none;
    border-radius: 6px;
  }

  .chat-sidebar a:hover {
    background: #f0f0f0;
  }

  .thread-link.active {
    background: #e6f7ff;
    font-weight: 600;
  }

  @media (max-width: 900px) {
    .chat-layout { flex-direction: column; }
    .chat-sidebar { width: 100%; height: auto; }
    .chat-container { max-width: 100%; }
  }

  .chat-header {
    background: #00c300;
    color: white;
    padding: 10px 20px;
    border-radius: 10px 10px 0 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .chat-header img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
  }

  .messages-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    background: #ffffff;
  }

  .message {
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
  }

  .message.sent {
    flex-direction: row-reverse;
  }

  .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #f0f0f0;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .attach-btn {
    background: #f0f0f0;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .attachment {
    margin-top: 5px;
    padding: 8px 12px;
    background: #f8f8f8;
    border-radius: 8px;
    display: inline-block;
    transition: background-color 0.2s;
  }

  .attachment:hover {
    background: #f0f0f0;
  }

  .file-link {
    display: flex;
    align-items: center;
    text-decoration: none;
    color: #333;
  }

  .file-icon {
    margin-right: 8px;
    font-size: 1.2em;
  }

  .filename {
    font-size: 0.9em;
    word-break: break-all;
  }

  .attachment-preview {
    margin-top: 8px;
    max-width: 300px;
    background: #f8f8f8;
    border-radius: 12px;
    overflow: hidden;
  }

  .image-link {
    display: block;
  }

  .file-preview {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.2s;
  }

  .file-preview:hover {
    opacity: 0.9;
  }

  .attachment-info {
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-top: 1px solid #eee;
  }

  .download-btn {
    padding: 4px 8px;
    border-radius: 4px;
    background: #00c300;
    color: white;
    text-decoration: none;
    font-size: 0.9em;
  }

  .download-btn:hover {
    background: #00b300;
  }

  .read-receipt {
    font-size: 0.8em;
    color: #00c300;
    text-align: right;
    cursor: pointer;
  }

  .read-receipt:hover {
    text-decoration: underline;
  }

  .read-receipt-tooltip {
    position: absolute;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    font-size: 0.9em;
    z-index: 100;
    display: none;
  }

  .read-receipt-tooltip.show {
    display: block;
  }

  .read-receipt-list {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  .read-receipt-list li {
    padding: 4px 0;
    border-bottom: 1px solid #eee;
  }

  .read-receipt-list li:last-child {
    border-bottom: none;
  }

  /* „Çπ„Ç≥„Ç¢‰ªò‰∏é„Å®Ë°®Á§∫„ÅÆ„Çπ„Çø„Ç§„É´ */
  .score {
    display: inline-block;
    padding: 2px 8px;
    background: #ffeb3b;
    border-radius: 12px;
    font-size: 0.9em;
    margin-left: 5px;
  }

  .score-form {
    display: none;
    margin-top: 5px;
    padding: 8px;
    background: #f8f8f8;
    border-radius: 8px;
    border: 1px solid #ddd;
  }

  .message.received .score-form {
    margin-left: 50px;
  }

  .score-form.show {
    display: block;
  }

  .score-form input[type="number"] {
    width: 60px;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-right: 8px;
  }

  .score-form textarea {
    width: 100%;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin: 8px 0;
    resize: vertical;
    min-height: 60px;
  }

  .score-form button {
    background: #00c300;
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 4px;
    cursor: pointer;
  }

  .score-button {
    background: transparent;
    border: 1px solid #00c300;
    color: #00c300;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.9em;
    margin-left: 5px;
    cursor: pointer;
  }

  .score-display {
    display: inline-block;
    margin-left: 5px;
  }

  /* Ê∑ª‰ªò„Éï„Ç°„Ç§„É´„ÅÆ„Éó„É¨„Éì„É•„Éº */
  .file-preview {
    max-width: 200px;
    max-height: 200px;
    object-fit: contain;
    border-radius: 10px;
    margin-top: 5px;
  }

  /* „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„ÅÆ„Ç´„Çπ„Çø„Éû„Ç§„Ç∫ */
  .file-input {
    display: none;
  }

  .upload-progress {
    background: #f0f0f0;
    border-radius: 10px;
    height: 4px;
    margin: 5px 0;
    overflow: hidden;
  }

  .upload-progress .bar {
    background: #00c300;
    height: 100%;
    width: 0;
    transition: width 0.3s ease;
  }

  .upload-error {
    color: #ff4444;
    font-size: 0.9em;
    margin: 5px 0;
  }

  #reconnectBtn {
    background: #ff4444;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    margin-right: 10px;
    cursor: pointer;
  }
</style>

<!-- ‚úÖ CSRF „Éà„Éº„ÇØ„É≥„ÇíÂÆâÂÖ®„Å™‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ -->
<form id="csrf-form" style="display:none;">
  {% csrf_token %}
</form>

<div id="chat-window">
  <div class="chat-layout">
    <aside class="chat-sidebar">
      <h4>„ÉÅ„É£„ÉÉ„Éà„Éä„Éì</h4>

      <div class="talks">
        <h5>„Éà„Éº„ÇØ</h5>
        {% if groups_with_threads %}
          {% for gw in groups_with_threads %}
            <div class="group-block">
              <strong>{{ gw.group.group_name }}</strong>
              {% for t in gw.threads %}
                <a href="#" class="thread-link" data-thread-id="{{ t.thread_id }}">{{ t.title }}</a>
              {% endfor %}
            </div>
          {% endfor %}
        {% endif %}

        {% if ungrouped_threads %}
          <div class="group-block">
            <strong>Êú™ÂàÜÈ°û</strong>
            {% for t in ungrouped_threads %}
              <a href="#" class="thread-link" data-thread-id="{{ t.thread_id }}">{{ t.title }}</a>
            {% endfor %}
          </div>
        {% endif %}
      </div>

      <hr>
      <a href="{% url 'codemon:thread_list' %}">„Çπ„É¨„ÉÉ„Éâ‰∏ÄË¶ß</a>
      <a href="{% url 'codemon:thread_create' %}">„Çπ„É¨„ÉÉ„Éâ‰ΩúÊàê</a>
      <a href="{% url 'codemon:group_list' %}">„Ç∞„É´„Éº„Éó‰∏ÄË¶ß</a>
      <a href="{% url 'codemon:group_create' %}">„Ç∞„É´„Éº„Éó‰ΩúÊàê</a>
      <hr>
    </aside>
    <div class="chat-container">
  </div>
</div>

<script>
  // ‚úÖ Django„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çø„Ç∞„ÇíÂÆâÂÖ®„Å´‰Ωø„ÅÜÔºàÊ¨†„Åë„Å¶„ÅÑ„ÇãÂ§âÊï∞„ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
  const csrfInput = document.querySelector('#csrf-form input[name="csrfmiddlewaretoken"]');
  const csrfToken = csrfInput ? csrfInput.value : '';
  const userId = "{{ request.user.id|default:'' }}";
  // chat „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÑ ws_url „Åå„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅßÊ∏°„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„Å´ÂÇô„Åà„Å¶„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Çí‰Ωø„ÅÜ
  let chatId = "{{ chat.id|default:'' }}";
  let wsUrl = "{{ ws_url|default:'' }}";
  const selectedThreadId = "{{ selected_thread_id|default:'' }}";
  const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
  const host = window.location.host;
  // If view provided ws_url use it, otherwise if a thread is already selected connect to its ws endpoint.
  if (!wsUrl) {
    if (selectedThreadId) {
      wsUrl = proto + host + '/ws/chat/' + selectedThreadId + '/';
    } else {
      wsUrl = ''; // no WS until user selects a thread
    }
  }
  const downloadBaseUrl = "{% url 'codemon:download_attachment' attachment_id=999999 %}".replace('999999', '');

  const chatBody = document.getElementById('chatBody');
  let socket;
  let isSending = false;

  const connectionStatus = document.getElementById('connectionStatus');
  connectionStatus.textContent = "Êé•Á∂ö‰∏≠...";

  function connectWebSocketWithRetry(retryCount = 0) {
    const MAX_RETRIES = 5;
    try {
      socket = new WebSocket(wsUrl);
    } catch (e) {
      console.error('WebSocket ‰ΩúÊàê„Å´Â§±Êïó:', e);
      connectionStatus.textContent = '‚ö†Ô∏è WebSocket „Ç®„É©„Éº';
      return;
    }

    socket.onopen = () => {
      connectionStatus.textContent = "üü¢ Êé•Á∂öÊ∏à„Åø";
      connectionStatus.classList.remove('alert');
      sendQueuedMessages();
    };

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      // Normalize incoming message payloads to expected shape
      const raw = data.message || data;
      if (!raw) return;
      const msg = {
        id: raw.message_id || raw.id || raw.messageId || null,
        content: raw.content || raw.text || '',
        user_id: raw.sender_id || raw.user_id || (raw.sender && raw.sender.user_id) || '',
        username: raw.sender_name || raw.username || (raw.sender && raw.sender.user_name) || '',
        created_at: raw.created_at || raw.timestamp || '',
        attachments: (raw.attachments || []).map(a => ({
          id: a.attachment_id || a.id || a.attachmentId || '',
          url: a.url || a.file_url || (a.file && a.file.url) || '',
          filename: a.filename || a.name || a.original_name || ''
        })),
        avatar_url: raw.sender_avatar || raw.avatar_url || null
      };
      const messageElement = createMessageElement(msg);
      chatBody.appendChild(messageElement);
      chatBody.scrollTop = chatBody.scrollHeight;
    };

    socket.onclose = () => {
      connectionStatus.textContent = "üî¥ ÂàáÊñ≠";
      connectionStatus.classList.add('alert');
      if (retryCount < MAX_RETRIES) {
        setTimeout(() => connectWebSocketWithRetry(retryCount + 1), 2000);
      }
    };

    socket.onerror = (error) => {
      console.error('WebSocket„Ç®„É©„Éº:', error);
      connectionStatus.textContent = "‚ö†Ô∏è ÈÄö‰ø°„Ç®„É©„Éº";
      connectionStatus.classList.add('alert');
    };
  }

  // ‚úÖ ÂÜçÊé•Á∂ö„Éú„Çø„É≥„ÅØÊ≠£„Åó„ÅÑÈñ¢Êï∞„ÇíÂëº„Å∂„Çà„ÅÜ„Å´Â§âÊõ¥
  const reconnectBtn = document.createElement('button');
  reconnectBtn.textContent = "ÂÜçÊé•Á∂ö";
  reconnectBtn.classList.add('btn', 'btn-warning', 'btn-sm');
  reconnectBtn.style.marginLeft = '10px';
  reconnectBtn.addEventListener('click', () => connectWebSocketWithRetry());
  connectionStatus.insertAdjacentElement('afterend', reconnectBtn);

  // ‚úÖ „Éï„Ç°„Ç§„É´Ê∑ª‰ªòÂá¶ÁêÜ
  document.getElementById('fileInput').addEventListener('change', async function (event) {
    const files = event.target.files;
    const formData = new FormData();
    for (const file of files) {
      formData.append('attachments', file);
    }

    const response = await fetch("{% url 'codemon:upload_attachments' %}", {
      method: 'POST',
      headers: { 'X-CSRFToken': csrfToken },
      body: formData
    });
    const data = await response.json();
    alert('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü: ' + data.attachments.length + ' ‰ª∂');
  });

  // ‚úÖ ÈÄÅ‰ø°„Éú„Çø„É≥Âá¶ÁêÜ‰øÆÊ≠£Áâà
  document.getElementById('sendBtn').addEventListener('click', async () => {
    const content = document.getElementById('messageInput').value.trim();
    const sendBtn = document.getElementById('sendBtn');
    if (!content && !document.getElementById('fileInput').files.length) return;
    if (isSending) return;
    isSending = true;
    sendBtn.disabled = true;

    const payload = {
      type: 'send_message',
      chat_id: chatId,
      content: content,
      user_id: userId,
    };

    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(payload));
    } else {
      enqueueMessage(payload);
      connectionStatus.textContent = "‚ö†Ô∏è „Ç™„Éï„É©„Ç§„É≥ - ÂÜçÈÄÅÂæÖÊ©ü‰∏≠";
    }

    document.getElementById('messageInput').value = '';
    isSending = false;
    sendBtn.disabled = false;
  });

  // ‚úÖ „É°„ÉÉ„Çª„Éº„Ç∏DOMÁîüÊàêÔºàÂÆâÂÖ®„Å´„ÄÅÊßò„ÄÖ„Å™„É°„ÉÉ„Çª„Éº„Ç∏ÂΩ¢Âºè„Å´ÂØæÂøúÔºâ
  function createMessageElement(msg) {
    const div = document.createElement('div');
    const isOwn = String(msg.user_id) === String(userId) && userId !== '';
    div.classList.add('message');
    div.classList.add(isOwn ? 'sent' : 'received');
    if (msg.id) div.dataset.messageId = msg.id;

    // „É°„ÇøÊÉÖÂ†±Ôºà„É¶„Éº„Ç∂„ÉºÂêç„ÉªÊôÇÈñìÔºâ
    const meta = document.createElement('div');
    meta.className = 'message-meta';
    const username = msg.username || msg.user_name || 'ÂåøÂêç';
    const ts = msg.timestamp || msg.created_at || '';
    meta.textContent = `${username}${ts ? '„Éª' + ts : ''}`;

    // „Ç≥„É≥„ÉÜ„É≥„ÉÑ
    const content = document.createElement('div');
    content.className = 'message-bubble';
    content.textContent = msg.content || '';

    // Attachments
    let attachmentsContainer = null;
    const attachments = msg.attachments || [];
    if (attachments.length) {
      attachmentsContainer = document.createElement('div');
      attachmentsContainer.className = 'image-container';
      attachments.forEach(a => {
        const item = document.createElement('div');
        item.className = 'image-item';
        const link = document.createElement('a');
        link.className = 'image-link';
        link.target = '_blank';
        link.href = downloadBaseUrl + (a.id || a.attachment_id || '');
        const img = document.createElement('img');
        img.src = a.url || a.file_url || '';
        img.alt = a.filename || '';
        img.style.maxWidth = '200px';
        img.style.borderRadius = '8px';
        item.appendChild(link);
        link.appendChild(img);
        attachmentsContainer.appendChild(item);
      });
    }

    // ÁµÑ„ÅøÁ´ã„Å¶
    div.appendChild(meta);
    div.appendChild(content);
    if (attachmentsContainer) div.appendChild(attachmentsContainer);
    return div;
  }

  // ‚úÖ „É≠„Éº„Ç´„É´ÈÄÅ‰ø°„Ç≠„É•„ÉºÔºà„Ç™„Éï„É©„Ç§„É≥ÂØæÂøúÔºâ
  function enqueueMessage(message) {
    const queue = JSON.parse(localStorage.getItem('messageQueue') || '[]');
    queue.push(message);
    localStorage.setItem('messageQueue', JSON.stringify(queue));
  }

  function sendQueuedMessages() {
    const queue = JSON.parse(localStorage.getItem('messageQueue') || '[]');
    queue.forEach(msg => socket.send(JSON.stringify(msg)));
    localStorage.removeItem('messageQueue');
  }

  // ‚úÖ ÂàùÂõûÊé•Á∂ö
  if (wsUrl) connectWebSocketWithRetry();

  // ===== Thread message loading =====
  const threadMessagesTemplate = "{% url 'codemon:thread_messages_api' 0 %}";
  function getThreadMessagesUrl(id) {
    // replace '/0/' with the real id
    return threadMessagesTemplate.replace('/0/', '/' + id + '/');
  }

  function renderMessages(messages) {
    chatBody.innerHTML = '';
    messages.forEach(m => {
      const mapped = {
        id: m.id,
        user_id: m.user_id,
        username: m.username,
        content: m.content,
        timestamp: m.created_at,
        attachments: m.attachments || []
      };
      chatBody.appendChild(createMessageElement(mapped));
    });
    chatBody.scrollTop = chatBody.scrollHeight;
  }

  function loadThread(threadId) {
    if (!threadId) return;
    // Ensure WebSocket connects to the selected thread's group
    const newWs = proto + host + '/ws/chat/' + threadId + '/';
    if (newWs !== wsUrl) {
      wsUrl = newWs;
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close();
      }
      connectWebSocketWithRetry();
    }
    const url = getThreadMessagesUrl(threadId);
    connectionStatus.textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
    fetch(url, { credentials: 'same-origin' })
      .then(r => {
        if (!r.ok) throw new Error('HTTP ' + r.status);
        return r.json();
      })
      .then(data => {
        renderMessages(data.messages || []);
        connectionStatus.textContent = 'üü¢ Êé•Á∂öÊ∏à„Åø';
        document.querySelectorAll('.thread-link').forEach(el => el.classList.remove('active'));
        const sel = document.querySelector(`.thread-link[data-thread-id="${threadId}"]`);
        if (sel) sel.classList.add('active');
      })
      .catch(err => {
        console.error('„Éà„Éº„ÇØË™≠„ÅøËæº„ÅøÂ§±Êïó', err);
        connectionStatus.textContent = 'Ë™≠„ÅøËæº„ÅøÂ§±Êïó';
      });
  }

  document.querySelectorAll('.thread-link').forEach(el => {
    el.addEventListener('click', function (e) {
      e.preventDefault();
      const id = this.dataset.threadId;
      loadThread(id);
    });
  });

  // If server provided initial messages, render them
  try {
    const initialMessages = {{ initial_messages_json|default:'[]'|safe }};
    if (initialMessages && initialMessages.length) {
      renderMessages(initialMessages);
      if ("{{ selected_thread_id|default:'' }}") {
        const selId = "{{ selected_thread_id }}";
        const sel = document.querySelector(`.thread-link[data-thread-id="${selId}"]`);
        if (sel) sel.classList.add('active');
      }
    }
  } catch (e) {
    console.warn('initial_messages „ÅÆÊèèÁîª„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', e);
  }
</script>
{% endblock %}
